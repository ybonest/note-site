(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{252:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MarkedContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return markedSource; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar _this = undefined,\n    _jsxFileName = "D:\\\\Workspace\\\\note-site\\\\app\\\\context.tsx";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\nvar dataSource = {\n  categoryByTag: {\n    http协议: [{\n      namehash: "c84g5s",\n      name: "读懂http协议",\n      title: "http协议",\n      description: "http协议是基于TCP/IP协议之上的应用层协议，HTTP默认端口：80，HTTPS默认端口443",\n      group: "",\n      image: "",\n      date: ""\n    }],\n    javascript: [{\n      namehash: "1i15e3e",\n      name: "惰性函数",\n      title: "惰性函数",\n      description: "惰性函数即函数执行后，原函数在函数内部被重新定义，之后调用只执行重新定义的函数，常用在内部状态稳定不变，即执行环境条件确定后，之后无论调用多少次函数，都返回同样结果或函数，此时可以使用惰性函数，直接重新定义函数。",\n      group: "",\n      image: "",\n      date: ""\n    }, {\n      namehash: "1vojcfp",\n      name: "执行上下文与变量提升",\n      title: "执行上下文与变量提升",\n      description: "正确理解执行上下文和执行栈的概念将使您成为更出色的 JavaScript 开发者",\n      group: "",\n      image: "",\n      date: ""\n    }, {\n      namehash: "19pnwe3",\n      name: "执行栈任务队列以及尾调用",\n      title: "尾调用与执行栈任务队列",\n      description: "尾调用与执行栈任务队列",\n      group: "",\n      image: "",\n      date: ""\n    }, {\n      namehash: "8guwtt",\n      name: "继承实现",\n      title: "继承",\n      description: "所谓继承，就是把一些有共性的东西分类，然后提取公共属性，当定义子类时直接从父类中继承这些具有共性的方法或属性，ES6以前JS并没有提供原生继承方式，但是可以通过函数以及原型链的一些特性模拟出继承",\n      group: "",\n      image: "",\n      date: ""\n    }, {\n      namehash: "1prwcdw",\n      name: "设计模式",\n      title: "设计模式",\n      description: "设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案",\n      group: "",\n      image: "",\n      date: ""\n    }, {\n      namehash: "19aptld",\n      name: "面向切面编程",\n      title: "面向切面编程",\n      description: "面向切面编程",\n      group: "",\n      image: "",\n      date: ""\n    }],\n    React: [{\n      namehash: "jun82s",\n      name: "context用法",\n      title: "React.createContext新的上下文",\n      description: "React.createContext新的上下文",\n      group: "",\n      image: "",\n      date: "2018-09-09"\n    }, {\n      namehash: "1h54ia4",\n      name: "hooks基础用法",\n      title: "hooks基础用法",\n      description: "hooks的出现使得函数式组件得以有自己的状态(useState)，更为高级的是通过useEffect我们可以模拟class组件的生命周期，使得函数式组件可以基本代替class组件",\n      group: "",\n      image: "",\n      date: "2018-09-09"\n    }, {\n      namehash: "1qe6sua",\n      name: "lazy与suspend",\n      title: "React.lazy与Suspense",\n      description: "React.lazy与Suspense",\n      group: "",\n      image: "",\n      date: "2018-09-09"\n    }, {\n      namehash: "1xoxkdj",\n      name: "react-redux介绍",\n      title: "react-redux介绍",\n      description: "react-redux本质上是一个作为react与redux之间联系的桥梁，它在监听redux状态变化，一旦redux更新，监听生效，新的数据状态就会被react-redux获取，从而react组件",\n      group: "redux系列",\n      image: "",\n      date: ""\n    }, {\n      namehash: "1m9nqkt",\n      name: "redux源码系列之中间件",\n      title: "redux源码系列之中间件",\n      description: "redux源码系列之中间件",\n      group: "redux系列",\n      image: "",\n      date: "2018-09-15"\n    }, {\n      namehash: "1gzo3l6",\n      name: "React源码分析之ReactBaseClasses",\n      title: "React源码分析之ReactBaseClasses",\n      description: "ReactBaseClasses中定义了Component与PureComponent两个基类，以及基类中的基本api，包括props、context、refs、updater、isReactComponent、setState、forceUpdate。要注意Component与PureComponent仅仅是使用ES6语法定义的模版，在项目编译时，使用这两个基类创建的组件最终还是会被转变成React对象形式。",\n      group: "React源码系列",\n      image: "",\n      date: "2018-09-09"\n    }, {\n      namehash: "kamhfm",\n      name: "React源码分析之ReactElement",\n      title: "React源码分析之ReactElement",\n      description: "ReactElement是React中的一些最基本接口，包括一个React对象的创建、拷贝与验证等。",\n      group: "React源码系列",\n      image: "",\n      date: "2018-09-11"\n    }, {\n      namehash: "gunvd0",\n      name: "从setState的异步与同步来解析React的状态机制",\n      title: "从setState的异步与同步来解析React的状态机制",\n      description: "从setState的异步与同步来解析React的状态机制",\n      group: "React源码系列",\n      image: "",\n      date: "2018-09-11"\n    }],\n    webpack: [{\n      namehash: "dwtwla",\n      name: "用babel来模拟webpack的编译实现",\n      title: "用babel来模拟webpack的编译实现",\n      description: "webpack强大不容置疑，是前端工程化体系必不可缺的一份力量，那它是怎样实现文件打包的，此处通过babel来写一个简易脚本来模拟webpack打包",\n      group: "",\n      image: "",\n      date: "2020-04-09"\n    }]\n  },\n  flatList: [{\n    content: __webpack_require__(280),\n    namehash: "dwtwla",\n    name: "用babel来模拟webpack的编译实现",\n    title: "用babel来模拟webpack的编译实现",\n    description: "webpack强大不容置疑，是前端工程化体系必不可缺的一份力量，那它是怎样实现文件打包的，此处通过babel来写一个简易脚本来模拟webpack打包",\n    tag: "webpack",\n    group: "",\n    image: "",\n    date: "2020-04-09"\n  }, {\n    content: __webpack_require__(281),\n    namehash: "1m9nqkt",\n    name: "redux源码系列之中间件",\n    title: "redux源码系列之中间件",\n    description: "redux源码系列之中间件",\n    tag: "React",\n    group: "redux系列",\n    image: "",\n    date: "2018-09-15"\n  }, {\n    content: __webpack_require__(282),\n    namehash: "kamhfm",\n    name: "React源码分析之ReactElement",\n    title: "React源码分析之ReactElement",\n    description: "ReactElement是React中的一些最基本接口，包括一个React对象的创建、拷贝与验证等。",\n    tag: "React",\n    group: "React源码系列",\n    image: "",\n    date: "2018-09-11"\n  }, {\n    content: __webpack_require__(283),\n    namehash: "gunvd0",\n    name: "从setState的异步与同步来解析React的状态机制",\n    title: "从setState的异步与同步来解析React的状态机制",\n    description: "从setState的异步与同步来解析React的状态机制",\n    tag: "React",\n    group: "React源码系列",\n    image: "",\n    date: "2018-09-11"\n  }, {\n    content: __webpack_require__(284),\n    namehash: "1xoxkdj",\n    name: "react-redux介绍",\n    title: "react-redux介绍",\n    description: "react-redux本质上是一个作为react与redux之间联系的桥梁，它在监听redux状态变化，一旦redux更新，监听生效，新的数据状态就会被react-redux获取，从而react组件",\n    tag: "React",\n    group: "redux系列",\n    image: "",\n    date: ""\n  }, {\n    content: __webpack_require__(285),\n    namehash: "jun82s",\n    name: "context用法",\n    title: "React.createContext新的上下文",\n    description: "React.createContext新的上下文",\n    tag: "React",\n    group: "",\n    image: "",\n    date: "2018-09-09"\n  }, {\n    content: __webpack_require__(286),\n    namehash: "1h54ia4",\n    name: "hooks基础用法",\n    title: "hooks基础用法",\n    description: "hooks的出现使得函数式组件得以有自己的状态(useState)，更为高级的是通过useEffect我们可以模拟class组件的生命周期，使得函数式组件可以基本代替class组件",\n    tag: "React",\n    group: "",\n    image: "",\n    date: "2018-09-09"\n  }, {\n    content: __webpack_require__(287),\n    namehash: "1qe6sua",\n    name: "lazy与suspend",\n    title: "React.lazy与Suspense",\n    description: "React.lazy与Suspense",\n    tag: "React",\n    group: "",\n    image: "",\n    date: "2018-09-09"\n  }, {\n    content: __webpack_require__(288),\n    namehash: "1gzo3l6",\n    name: "React源码分析之ReactBaseClasses",\n    title: "React源码分析之ReactBaseClasses",\n    description: "ReactBaseClasses中定义了Component与PureComponent两个基类，以及基类中的基本api，包括props、context、refs、updater、isReactComponent、setState、forceUpdate。要注意Component与PureComponent仅仅是使用ES6语法定义的模版，在项目编译时，使用这两个基类创建的组件最终还是会被转变成React对象形式。",\n    tag: "React",\n    group: "React源码系列",\n    image: "",\n    date: "2018-09-09"\n  }, {\n    content: __webpack_require__(289),\n    namehash: "19aptld",\n    name: "面向切面编程",\n    title: "面向切面编程",\n    description: "面向切面编程",\n    tag: "javascript",\n    group: "",\n    image: "",\n    date: ""\n  }, {\n    content: __webpack_require__(290),\n    namehash: "1prwcdw",\n    name: "设计模式",\n    title: "设计模式",\n    description: "设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案",\n    tag: "javascript",\n    group: "",\n    image: "",\n    date: ""\n  }, {\n    content: __webpack_require__(291),\n    namehash: "8guwtt",\n    name: "继承实现",\n    title: "继承",\n    description: "所谓继承，就是把一些有共性的东西分类，然后提取公共属性，当定义子类时直接从父类中继承这些具有共性的方法或属性，ES6以前JS并没有提供原生继承方式，但是可以通过函数以及原型链的一些特性模拟出继承",\n    tag: "javascript",\n    group: "",\n    image: "",\n    date: ""\n  }, {\n    content: __webpack_require__(292),\n    namehash: "19pnwe3",\n    name: "执行栈任务队列以及尾调用",\n    title: "尾调用与执行栈任务队列",\n    description: "尾调用与执行栈任务队列",\n    tag: "javascript",\n    group: "",\n    image: "",\n    date: ""\n  }, {\n    content: __webpack_require__(295),\n    namehash: "1vojcfp",\n    name: "执行上下文与变量提升",\n    title: "执行上下文与变量提升",\n    description: "正确理解执行上下文和执行栈的概念将使您成为更出色的 JavaScript 开发者",\n    tag: "javascript",\n    group: "",\n    image: "",\n    date: ""\n  }, {\n    content: __webpack_require__(296),\n    namehash: "1i15e3e",\n    name: "惰性函数",\n    title: "惰性函数",\n    description: "惰性函数即函数执行后，原函数在函数内部被重新定义，之后调用只执行重新定义的函数，常用在内部状态稳定不变，即执行环境条件确定后，之后无论调用多少次函数，都返回同样结果或函数，此时可以使用惰性函数，直接重新定义函数。",\n    tag: "javascript",\n    group: "",\n    image: "",\n    date: ""\n  }, {\n    content: __webpack_require__(297),\n    namehash: "c84g5s",\n    name: "读懂http协议",\n    title: "http协议",\n    description: "http协议是基于TCP/IP协议之上的应用层协议，HTTP默认端口：80，HTTPS默认端口443",\n    tag: "http协议",\n    group: "",\n    image: "",\n    date: ""\n  }]\n};\nvar MarkedContext = react__WEBPACK_IMPORTED_MODULE_0__["createContext"](dataSource);\nvar markedSource = function markedSource(Element) {\n  return function () {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](MarkedContext.Consumer, {\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 408,\n        columnNumber: 3\n      }\n    }, function (value) {\n      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Element, _extends({}, value, {\n        __self: _this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 409,\n          columnNumber: 17\n        }\n      }));\n    });\n  };\n};\n\n//# sourceURL=webpack:///./app/context.tsx?')},260:function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return TagsCard; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);\n/* harmony import */ var _components_styled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);\n/* harmony import */ var _app_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(252);\nvar _this = undefined,\n    _jsxFileName = \"D:\\\\Workspace\\\\note-site\\\\components\\\\Tags.tsx\";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\nvar colorsMap = [{\n  backgroundColor: '#8080c0',\n  color: ''\n}, {\n  backgroundColor: '#e8d098',\n  color: ''\n}, {\n  backgroundColor: '#336699',\n  color: ''\n}, {\n  backgroundColor: '#b45b3e',\n  color: ''\n}, {\n  backgroundColor: '#66cccc',\n  color: ''\n}, {\n  backgroundColor: '#00b271',\n  color: ''\n}, {\n  backgroundColor: '#d7fff0',\n  color: ''\n}, {\n  backgroundColor: '#479ac7',\n  color: ''\n}, {\n  backgroundColor: '#f0dad2',\n  color: ''\n}];\nvar TagsCard = Object(_app_context__WEBPACK_IMPORTED_MODULE_3__[/* markedSource */ \"b\"])(function (props) {\n  var categoryByTag = props.categoryByTag;\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](_components_styled__WEBPACK_IMPORTED_MODULE_2__[/* Card */ \"a\"], {\n    __self: _this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 38,\n      columnNumber: 5\n    }\n  }, Object.keys(categoryByTag).map(function (tag) {\n    var colors = colorsMap[0];\n    colorsMap.push(colorsMap.shift());\n    console.log(colors, colorsMap.length, \":::::::\");\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](_components_styled__WEBPACK_IMPORTED_MODULE_2__[/* Tag */ \"h\"], _extends({}, colors, {\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 44,\n        columnNumber: 13\n      }\n    }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"](react_router_dom__WEBPACK_IMPORTED_MODULE_1__[/* Link */ \"b\"], {\n      key: tag,\n      to: '/tags/' + tag,\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 45,\n        columnNumber: 15\n      }\n    }, tag));\n  }));\n});\n\n//# sourceURL=webpack:///./components/Tags.tsx?")},261:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export Introduction */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IntroductionList; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54);\n/* harmony import */ var _components_styled__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55);\n/* harmony import */ var _app_loadImages__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(298);\n/* harmony import */ var _app_loadImages__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_app_loadImages__WEBPACK_IMPORTED_MODULE_3__);\nvar _jsxFileName = "D:\\\\Workspace\\\\note-site\\\\components\\\\Introduction.tsx";\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n\n\n\n\nfunction Introduction(props) {\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](react_router_dom__WEBPACK_IMPORTED_MODULE_1__[/* Link */ "b"], {\n    to: \'/\' + props.namehash,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 8,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](_components_styled__WEBPACK_IMPORTED_MODULE_2__[/* Synopsis */ "g"], {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 9,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("div", {\n    className: "note-title",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 10,\n      columnNumber: 9\n    }\n  }, props.image && props.image !== \'\' && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("img", {\n    src: _app_loadImages__WEBPACK_IMPORTED_MODULE_3__[props.image],\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 11,\n      columnNumber: 49\n    }\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("p", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 12,\n      columnNumber: 11\n    }\n  }, props.title, props.date && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("span", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 12,\n      columnNumber: 42\n    }\n  }, "(", props.date, ")")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"]("p", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 13,\n      columnNumber: 11\n    }\n  }, props.description))));\n}\nfunction IntroductionList(props) {\n  var _this = this;\n\n  return props.dataSource.map(function (item) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__["createElement"](Introduction, _extends({\n      key: item.namehash\n    }, item, {\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 21,\n        columnNumber: 39\n      }\n    }));\n  });\n}\n\n//# sourceURL=webpack:///./components/Introduction.tsx?')},280:function(module,exports){eval('// Module\nvar code = "<div class=note-title><p>用babel来模拟webpack的编译实现</p> <p>webpack强大不容置疑，是前端工程化体系必不可缺的一份力量，那它是怎样实现文件打包的，此处通过babel来写一个简易脚本来模拟webpack打包</p> </div><div class=note-content><h4>分析wenpack打包后的文件</h4> <p>假设有文件a、b</p> <p>文件a内容如下</p> <pre><code class=\\"hljs js\\"><span class=hljs-keyword>import</span> b <span class=hljs-keyword>from</span> <span class=hljs-string>\'./b.js\'</span>;\\n<span class=hljs-built_in>console</span>.log(b)</code></pre> <p>文件b内容如下</p> <pre><code class=\\"hljs js\\"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>add</span>(<span class=hljs-params></span>) </span>{}\\n<span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> add；</code></pre> <p>用webpack打包a、b文件后输出如下</p> <pre><code class=\\"hljs js\\">(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>modules</span>) </span>{ <span class=hljs-comment>// webpackBootstrap</span>\\n    <span class=hljs-keyword>var</span> installedModules = {};\\n    <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>__webpack_require__</span>(<span class=hljs-params>moduleId</span>) </span>{\\n        <span class=hljs-comment>// Check if module is in cache</span>\\n        <span class=hljs-keyword>if</span>(installedModules[moduleId]) {\\n            <span class=hljs-keyword>return</span> installedModules[moduleId].exports;\\n        }\\n        <span class=hljs-comment>// Create a new module (and put it into the cache)</span>\\n        <span class=hljs-keyword>var</span> <span class=hljs-built_in>module</span> = installedModules[moduleId] = {\\n            <span class=hljs-attr>i</span>: moduleId,\\n            <span class=hljs-attr>l</span>: <span class=hljs-literal>false</span>,\\n            <span class=hljs-attr>exports</span>: {}\\n        };\\n        <span class=hljs-comment>// Execute the module function</span>\\n        modules[moduleId].call(<span class=hljs-built_in>module</span>.exports, <span class=hljs-built_in>module</span>, <span class=hljs-built_in>module</span>.exports, __webpack_require__);\\n        <span class=hljs-comment>// Flag the module as loaded</span>\\n        <span class=hljs-built_in>module</span>.l = <span class=hljs-literal>true</span>;\\n        <span class=hljs-comment>// Return the exports of the module</span>\\n        <span class=hljs-keyword>return</span> <span class=hljs-built_in>module</span>.exports;\\n    }\\n    <span class=hljs-comment>// expose the modules object (__webpack_modules__)</span>\\n    __webpack_require__.m = modules;\\n    <span class=hljs-comment>// expose the module cache</span>\\n    __webpack_require__.c = installedModules;\\n    <span class=hljs-comment>// define getter function for harmony exports</span>\\n    __webpack_require__.d = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>exports, name, getter</span>) </span>{\\n        <span class=hljs-keyword>if</span>(!__webpack_require__.o(exports, name)) {\\n            <span class=hljs-built_in>Object</span>.defineProperty(exports, name, { <span class=hljs-attr>enumerable</span>: <span class=hljs-literal>true</span>, <span class=hljs-attr>get</span>: getter });\\n        }\\n    };\\n    <span class=hljs-comment>// define __esModule on exports</span>\\n    __webpack_require__.r = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>exports</span>) </span>{\\n        <span class=hljs-keyword>if</span>(<span class=hljs-keyword>typeof</span> <span class=hljs-built_in>Symbol</span> !== <span class=hljs-string>\'undefined\'</span> &amp;&amp; <span class=hljs-built_in>Symbol</span>.toStringTag) {\\n            <span class=hljs-built_in>Object</span>.defineProperty(exports, <span class=hljs-built_in>Symbol</span>.toStringTag, { <span class=hljs-attr>value</span>: <span class=hljs-string>\'Module\'</span> });\\n        }\\n        <span class=hljs-built_in>Object</span>.defineProperty(exports, <span class=hljs-string>\'__esModule\'</span>, { <span class=hljs-attr>value</span>: <span class=hljs-literal>true</span> });\\n    };\\n    <span class=hljs-comment>// create a fake namespace object</span>\\n    <span class=hljs-comment>// mode &amp; 1: value is a module id, require it</span>\\n    <span class=hljs-comment>// mode &amp; 2: merge all properties of value into the ns</span>\\n    <span class=hljs-comment>// mode &amp; 4: return value when already ns object</span>\\n    <span class=hljs-comment>// mode &amp; 8|1: behave like require</span>\\n    __webpack_require__.t = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>value, mode</span>) </span>{\\n        <span class=hljs-keyword>if</span>(mode &amp; <span class=hljs-number>1</span>) value = __webpack_require__(value);\\n        <span class=hljs-keyword>if</span>(mode &amp; <span class=hljs-number>8</span>) <span class=hljs-keyword>return</span> value;\\n        <span class=hljs-keyword>if</span>((mode &amp; <span class=hljs-number>4</span>) &amp;&amp; <span class=hljs-keyword>typeof</span> value === <span class=hljs-string>\'object\'</span> &amp;&amp; value &amp;&amp; value.__esModule) <span class=hljs-keyword>return</span> value;\\n        <span class=hljs-keyword>var</span> ns = <span class=hljs-built_in>Object</span>.create(<span class=hljs-literal>null</span>);\\n        __webpack_require__.r(ns);\\n        <span class=hljs-built_in>Object</span>.defineProperty(ns, <span class=hljs-string>\'default\'</span>, { <span class=hljs-attr>enumerable</span>: <span class=hljs-literal>true</span>, <span class=hljs-attr>value</span>: value });\\n        <span class=hljs-keyword>if</span>(mode &amp; <span class=hljs-number>2</span> &amp;&amp; <span class=hljs-keyword>typeof</span> value != <span class=hljs-string>\'string\'</span>) <span class=hljs-keyword>for</span>(<span class=hljs-keyword>var</span> key <span class=hljs-keyword>in</span> value) __webpack_require__.d(ns, key, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>key</span>) </span>{ <span class=hljs-keyword>return</span> value[key]; }.bind(<span class=hljs-literal>null</span>, key));\\n        <span class=hljs-keyword>return</span> ns;\\n    };\\n    <span class=hljs-comment>// getDefaultExport function for compatibility with non-harmony modules</span>\\n    __webpack_require__.n = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>module</span>) </span>{\\n        <span class=hljs-keyword>var</span> getter = <span class=hljs-built_in>module</span> &amp;&amp; <span class=hljs-built_in>module</span>.__esModule ?\\n            <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getDefault</span>(<span class=hljs-params></span>) </span>{ <span class=hljs-keyword>return</span> <span class=hljs-built_in>module</span>[<span class=hljs-string>\'default\'</span>]; } :\\n            <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getModuleExports</span>(<span class=hljs-params></span>) </span>{ <span class=hljs-keyword>return</span> <span class=hljs-built_in>module</span>; };\\n        __webpack_require__.d(getter, <span class=hljs-string>\'a\'</span>, getter);\\n        <span class=hljs-keyword>return</span> getter;\\n    };\\n    <span class=hljs-comment>// Object.prototype.hasOwnProperty.call</span>\\n    __webpack_require__.o = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>object, property</span>) </span>{ <span class=hljs-keyword>return</span> <span class=hljs-built_in>Object</span>.prototype.hasOwnProperty.call(object, property); };\\n    <span class=hljs-comment>// __webpack_public_path__</span>\\n    __webpack_require__.p = <span class=hljs-string>\\"\\"</span>;\\n    <span class=hljs-comment>// Load entry module and return exports</span>\\n    <span class=hljs-keyword>return</span> __webpack_require__(__webpack_require__.s = <span class=hljs-string>\\"./src/a.js\\"</span>);\\n})\\n({ <span class=hljs-string>\\"./src/a.js\\"</span>: (<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>module, __webpack_exports__, __webpack_require__</span>) </span>{\\n  <span class=hljs-string>\\"use strict\\"</span>;\\n  <span class=hljs-built_in>eval</span>(<span class=hljs-string>\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony import */ var _b_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./b.js */ \\\\\\"./src/b.js\\\\\\");\\\\n\\\\r\\\\nconsole.log(_b_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\"default\\\\\\"]);\\\\r\\\\nfunction a() {\\\\r\\\\n  console.log(9999)\\\\r\\\\n}\\\\r\\\\n\\\\n\\\\n//# sourceURL=webpack:///./src/a.js?\\"</span>); }),\\n\\n  <span class=hljs-string>\\"./src/b.js\\"</span>: (<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>module, __webpack_exports__, __webpack_require__</span>) </span>{\\n  <span class=hljs-string>\\"use strict\\"</span>;\\n  <span class=hljs-built_in>eval</span>(<span class=hljs-string>\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\\\\"default\\\\\\", function() { return add; });\\\\nfunction add() {}\\\\n\\\\n//# sourceURL=webpack:///./src/b.js?\\"</span>);\\n  })\\n});</code></pre> <p>可以看到，webpack读取文件后对import，exports等ES6语法进行了转换，<code>import</code> =&gt; <code>__webpack_require__</code>, <code>export</code> =&gt; <code>__webpack_exports__</code>，最终将需要打包的文件扁平化放进一个对象，路径做key，code为value传进webpack提供的一个自调用函数，这样require时，利用require的文件路径就可以在该对象去拿到资源。</p> <p><strong><code>__webpack_require__分析</code></strong></p> <pre><code class=\\"hljs js\\"><span class=hljs-keyword>var</span> installedModules = {};\\n    <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>__webpack_require__</span>(<span class=hljs-params>moduleId</span>) </span>{ <span class=hljs-comment>// moduleId就是资源路径</span>\\n         <span class=hljs-comment>// 这里先查看要require的文件有没被缓存，有缓存直接去缓存的结果</span>\\n        <span class=hljs-keyword>if</span>(installedModules[moduleId]) { \\n            <span class=hljs-keyword>return</span> installedModules[moduleId].exports;\\n        }\\n        <span class=hljs-comment>// 无缓存，则定义一个缓存对象</span>\\n        <span class=hljs-keyword>var</span> <span class=hljs-built_in>module</span> = installedModules[moduleId] = { \\n            <span class=hljs-attr>i</span>: moduleId,\\n            <span class=hljs-attr>l</span>: <span class=hljs-literal>false</span>,\\n            <span class=hljs-attr>exports</span>: {}\\n        };\\n    <span class=hljs-comment>/**\\n      *上面webpack打包后的文件可以看到源文件被包了一层方法，用来提供webpack定义的*__webpack_require__方法，此处调用该方法将__webpack_require__，exports传进需*import文件的作用域\\n      */</span>\\n        modules[moduleId].call(<span class=hljs-built_in>module</span>.exports, <span class=hljs-built_in>module</span>, <span class=hljs-built_in>module</span>.exports, __webpack_require__);\\n        <span class=hljs-comment>// Flag the module as loaded</span>\\n        <span class=hljs-built_in>module</span>.l = <span class=hljs-literal>true</span>;\\n        <span class=hljs-comment>// 上述方法被调用后，所有export的值都被放进了module.exports对象中，这样在上级文件中就可以访问该对象内容</span>\\n        <span class=hljs-keyword>return</span> <span class=hljs-built_in>module</span>.exports;\\n    }</code></pre> <p><strong>对应的我们来看看入口文件被编译结果（./src/a.js）</strong></p> <pre><code class=\\"hljs js\\"><span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>module, __webpack_exports__, __webpack_require__</span>) </span>{\\n  <span class=hljs-string>\\"use strict\\"</span>;\\n  <span class=hljs-built_in>eval</span>(<span class=hljs-string>\\"__webpack_require__.r(__webpack_exports__);\\\\n/* harmony import */ var _b_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./b.js */ \\\\\\"./src/b.js\\\\\\");\\\\n\\\\r\\\\nconsole.log(_b_js__WEBPACK_IMPORTED_MODULE_0__[\\\\\\"default\\\\\\"]);\\\\r\\\\nfunction a() {\\\\r\\\\n  console.log(9999)\\\\r\\\\n}\\\\r\\\\n\\\\n\\\\n//# sourceURL=webpack:///./src/a.js?\\"</span>); \\n}</code></pre> <p><strong>看看webpack是如何import的文件./src/b.js的</strong></p> <pre><code class=\\"hljs js\\"><span class=hljs-keyword>var</span> _b_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class=hljs-string>\\"./src/b.js\\\\\\");</span></code></pre> <p>这里就是将import转成了<strong>webpack_require</strong>函数，通过调用<strong>webpack_require</strong>就获取了目标文件所有被export的变量或函数</p> <p><strong>接下来再看看被import的文件</strong></p> <pre><code class=\\"hljs js\\"><span class=hljs-comment>// 1、在上面的 `__webpack_require__(\\"./src/b.js\\\\\\")`中这里被调用，</span>\\n<span class=hljs-comment>// 2、__webpack_require__提供module.exports传入方法，</span>\\n<span class=hljs-comment>// 3、最终通过__webpack_require__.d把./src/b.js文件中的所有export定义到module.exports对象上</span>\\n(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>module, __webpack_exports__, __webpack_require__</span>) </span>{\\n  <span class=hljs-string>\\"use strict\\"</span>;\\n  <span class=hljs-built_in>eval</span>(<span class=hljs-string>\\"__webpack_require__.r(__webpack_exports__); __webpack_require__.d(__webpack_exports__, \\\\\\"default\\\\\\", function() { return add; });\\\\nfunction add() {}\\\\n\\\\n//# sourceURL=webpack:///./src/b.js?\\"</span>);\\n  })</code></pre> <p>从输出后的打包文件可以了解webpack基本原理就是提供了<strong>webpack_require</strong>替换了export与import，下面通过babel模拟一下webpack打包实现。</p> <p><strong>首先提供template模板文件，也就是webpack提供<code>__webpack_require__</code>的自调用函数</strong></p> <pre><code class=\\"hljs js\\"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createTemplate</span>(<span class=hljs-params>colloctCodes</span>) </span>{\\n  <span class=hljs-keyword>return</span> <span class=hljs-string>`\\n  (function(modules) { // modules 存储了所有扁平化的路径+代码数据\\n    var cacheLoadedAModules = {};\\n    function _my_webpack_require(filepath) {\\n      if (cacheLoadedAModules[filepath]) {\\n        return cacheLoadedAModules[filepath].exports;\\n      }\\n\\n      /** 定义exports  在源文件中 export a或者export default b最终被编译为 exports.a 或者 exports.default = b*/\\n      var module = cacheLoadedAModules[filepath] = {\\n        exports: {}\\n      }\\n      // 此处去require文件\\n      modules[filepath].call(module.exports, module, _my_webpack_require, module.exports);\\n      return module.exports;\\n    }\\n\\n    _my_webpack_require.d = function(exports, key, value) {\\n      exports[key] = value;\\n    }\\n\\n    return _my_webpack_require(\'./src/a.js\');\\n  })({<span class=hljs-subst>${createTemplateParams(colloctCodes)}</span>})`</span>\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createTemplateParams</span>(<span class=hljs-params>colloctCodes</span>) </span>{\\n  <span class=hljs-keyword>return</span> <span class=hljs-built_in>Object</span>.keys(colloctCodes).reduce(<span class=hljs-function>(<span class=hljs-params>collect, key</span>) =&gt;</span> {\\n    collect += <span class=hljs-string>`\\\\n\'<span class=hljs-subst>${key}</span>\': function(module, _my_webpack_require, _my_webpack_export) {\\n      eval(\\"<span class=hljs-subst>${colloctCodes[key]}</span>\\")\\n    },`</span>;\\n    <span class=hljs-keyword>return</span> collect;\\n  }, <span class=hljs-string>\'\'</span>)\\n}\\n\\n<span class=hljs-built_in>module</span>.exports = createTemplate;</code></pre> <p><strong>第二步，利用babel转义文件中的import与export，并结合上述代码输出</strong></p> <pre><code class=\\"hljs js\\"><span class=hljs-keyword>const</span> commander = <span class=hljs-built_in>require</span>(<span class=hljs-string>\'commander\'</span>);\\n<span class=hljs-keyword>const</span> path = <span class=hljs-built_in>require</span>(<span class=hljs-string>\'path\'</span>);\\n<span class=hljs-keyword>const</span> fs = <span class=hljs-built_in>require</span>(<span class=hljs-string>\'fs\'</span>);\\n<span class=hljs-keyword>const</span> babelParser = <span class=hljs-built_in>require</span>(<span class=hljs-string>\'@babel/parser\'</span>); \\n<span class=hljs-keyword>const</span> babelCore = <span class=hljs-built_in>require</span>(<span class=hljs-string>\'@babel/core\'</span>);\\n<span class=hljs-keyword>const</span> { <span class=hljs-attr>default</span>: traverse } = <span class=hljs-built_in>require</span>(<span class=hljs-string>\'@babel/traverse\'</span>);\\n<span class=hljs-keyword>const</span> t = <span class=hljs-built_in>require</span>(<span class=hljs-string>\\"@babel/types\\"</span>)\\n<span class=hljs-keyword>const</span> createTemplate = <span class=hljs-built_in>require</span>(<span class=hljs-string>\'./template\'</span>);\\n<span class=hljs-keyword>const</span> prettier = <span class=hljs-built_in>require</span>(<span class=hljs-string>\'prettier\'</span>);\\n\\n<span class=hljs-keyword>const</span> argv = commander\\n  .version(<span class=hljs-built_in>require</span>(<span class=hljs-string>\'../package.json\'</span>).version)\\n  .requiredOption(<span class=hljs-string>\'--config &lt;webpack&gt;\'</span>)\\n  .parse(process.argv);\\n<span class=hljs-keyword>const</span> cwd = process.cwd();\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>loadConfigFile</span>(<span class=hljs-params>config_dir</span>) </span>{\\n  <span class=hljs-keyword>if</span> (config_dir) {\\n    <span class=hljs-keyword>return</span> <span class=hljs-built_in>require</span>(config_dir);\\n  }\\n  <span class=hljs-built_in>console</span>.error(<span class=hljs-string>\\"miss config!!!\\"</span>);\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>getCode</span>(<span class=hljs-params>filepath</span>) </span>{\\n  <span class=hljs-keyword>let</span> code;\\n  <span class=hljs-keyword>if</span> (<span class=hljs-keyword>typeof</span> filepath === <span class=hljs-string>\'string\'</span>) {\\n    code = fs.readFileSync(path.resolve(cwd, filepath), <span class=hljs-string>\\"utf8\\"</span>);\\n  }\\n  <span class=hljs-keyword>return</span> code;\\n}\\n\\n<span class=hljs-comment>// 利用babel对源文件的import 或者exports进行转换</span>\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>transform</span>(<span class=hljs-params>code, collectCode, directory</span>) </span>{\\n  <span class=hljs-keyword>const</span> parseAst = babelParser.parse(code, { <span class=hljs-attr>sourceType</span>: <span class=hljs-string>\\"module\\"</span> });\\n  <span class=hljs-keyword>let</span> importIndex = <span class=hljs-number>0</span>;\\n  <span class=hljs-keyword>const</span> dirname = path.dirname(directory);\\n  <span class=hljs-keyword>const</span> importIdentifier = {};\\n\\n  traverse(parseAst, {\\n    Identifier(astNode) {\\n      <span class=hljs-keyword>const</span> identifier = <span class=hljs-built_in>Reflect</span>.get(importIdentifier, astNode.node.name);\\n      <span class=hljs-keyword>if</span> (identifier) {\\n        astNode.replaceWith(identifier)\\n      }\\n    },\\n    ImportDeclaration(astNode) { <span class=hljs-comment>// 转义import语句，这里只考虑了 import b from \'./b\'的情景，未兼容import { c, d } from \'./b\'等其它较复杂情景</span>\\n      <span class=hljs-keyword>let</span> { <span class=hljs-attr>source</span>: argsNode } = astNode.node;\\n\\n      <span class=hljs-keyword>const</span> originName = <span class=hljs-built_in>Object</span>.keys(t.getBindingIdentifiers(astNode.node))[<span class=hljs-number>0</span>];\\n      importIdentifier[originName] = t.identifier(<span class=hljs-string>`_my_webpack_module_<span class=hljs-subst>${importIndex++}</span>`</span>);\\n      <span class=hljs-keyword>const</span> filePath = <span class=hljs-string>\'./\'</span> + path.join(dirname, path.dirname(argsNode.value)) + <span class=hljs-string>\'/\'</span> + path.basename(argsNode.value);\\n      argsNode.value = filePath;\\n      <span class=hljs-keyword>const</span> varNode = t.variableDeclaration(<span class=hljs-string>\\"var\\"</span>, [\\n        t.variableDeclarator(\\n          importIdentifier[originName],\\n          t.callExpression(t.identifier(<span class=hljs-string>`_my_webpack_require`</span>), [argsNode])\\n        )\\n      ]);\\n      astNode.replaceWith(varNode);\\n      transform(getCode(filePath), collectCode, filePath);\\n    },\\n    ExportDefaultDeclaration(astNode) { <span class=hljs-comment>// 转义export default语句</span>\\n      <span class=hljs-keyword>const</span> { declaration } = astNode.node;\\n      <span class=hljs-keyword>const</span> defaultVar = t.StringLiteral(<span class=hljs-string>\'default\'</span>);\\n      <span class=hljs-keyword>const</span> defineExports = t.identifier(<span class=hljs-string>\'_my_webpack_export\'</span>);\\n      <span class=hljs-keyword>const</span> defineCallFunc = t.identifier(<span class=hljs-string>`_my_webpack_require.d`</span>);\\n      <span class=hljs-keyword>let</span> right = declaration;\\n      <span class=hljs-keyword>if</span> (t.isAssignmentExpression(right)) {\\n        right = declaration.right;\\n      }\\n      <span class=hljs-keyword>if</span> (t.isFunctionDeclaration(right)) {\\n        right = t.functionExpression(<span class=hljs-literal>null</span>, right.params, right.body, right.generator, right.async)\\n      }\\n\\n      <span class=hljs-keyword>const</span> constant = t.callExpression(defineCallFunc, [defineExports, defaultVar, right]);\\n      astNode.replaceWith(constant)\\n    },\\n    ExportNamedDeclaration(astNode) {\\n      <span class=hljs-keyword>const</span> { declarations } = astNode.node.declaration;\\n      <span class=hljs-keyword>const</span> { id, init } = declarations[<span class=hljs-number>0</span>];\\n      <span class=hljs-keyword>const</span> defineExports = t.identifier(<span class=hljs-string>\'_my_webpack_export\'</span>);\\n      <span class=hljs-keyword>const</span> defineCallFunc = t.identifier(<span class=hljs-string>`_my_webpack_require.d`</span>);\\n      <span class=hljs-keyword>const</span> defineName = t.stringLiteral(id.name);\\n      <span class=hljs-keyword>const</span> constant = t.callExpression(defineCallFunc, [defineExports, defineName, init]);\\n      astNode.replaceWith(constant)\\n    }\\n  });\\n  <span class=hljs-keyword>let</span> { <span class=hljs-attr>code</span>: $code } = babelCore.transformFromAstSync(parseAst, code);\\n  $code = $code.split(<span class=hljs-string>\'\\\\n\'</span>).reduce(<span class=hljs-function>(<span class=hljs-params>c, line</span>) =&gt;</span> {\\n    line = line.trim().replace(<span class=hljs-regexp>/\\"/g</span>, <span class=hljs-string>\\"\'\\"</span>);\\n    <span class=hljs-keyword>if</span> (line === <span class=hljs-string>\'\'</span>) {\\n      <span class=hljs-keyword>return</span> c;\\n    }\\n    <span class=hljs-keyword>if</span> (line.endsWith(<span class=hljs-string>\';\'</span>)) {\\n      <span class=hljs-keyword>return</span> <span class=hljs-string>`<span class=hljs-subst>${c}</span><span class=hljs-subst>${line}</span>`</span>;\\n    }\\n    <span class=hljs-keyword>return</span> <span class=hljs-string>`<span class=hljs-subst>${c}</span><span class=hljs-subst>${line}</span>;`</span>;\\n  }, <span class=hljs-string>\'\'</span>)\\n  collectCode[directory] = $code;\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>compiler</span>(<span class=hljs-params>config</span>) </span>{\\n  <span class=hljs-keyword>const</span> webpackConfig = loadConfigFile(path.resolve(cwd, config));\\n\\n  <span class=hljs-keyword>const</span> collectCode = {}\\n  <span class=hljs-keyword>const</span> entryCode = getCode(webpackConfig.entry);\\n\\n  <span class=hljs-keyword>if</span> (entryCode) {\\n    transform(entryCode, collectCode, webpackConfig.entry);\\n  }\\n  <span class=hljs-keyword>const</span> template = prettier.format(createTemplate(collectCode), { <span class=hljs-attr>semi</span>: <span class=hljs-literal>false</span>, <span class=hljs-attr>parser</span>: <span class=hljs-string>\\"babel\\"</span> })\\n  <span class=hljs-built_in>console</span>.log(template)\\n}\\n</code></pre> <p><strong>最终输出文件</strong></p> <pre><code class=\\"hljs js\\">;(<span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>modules</span>) </span>{\\n  <span class=hljs-comment>// modules 存储了所有扁平化的路径+代码数据</span>\\n  <span class=hljs-keyword>var</span> cacheLoadedAModules = {}\\n  <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>_my_webpack_require</span>(<span class=hljs-params>filepath</span>) </span>{\\n    <span class=hljs-keyword>if</span> (cacheLoadedAModules[filepath]) {\\n      <span class=hljs-keyword>return</span> cacheLoadedAModules[filepath].exports\\n    }\\n\\n    <span class=hljs-comment>/** 定义exports  在源文件中 export a或者export default b最终被编译为 exports.a 或者 exports.default = b*/</span>\\n    <span class=hljs-keyword>var</span> <span class=hljs-built_in>module</span> = (cacheLoadedAModules[filepath] = {\\n      <span class=hljs-attr>exports</span>: {},\\n    })\\n    <span class=hljs-comment>// 此处去require文件</span>\\n    modules[filepath].call(\\n      <span class=hljs-built_in>module</span>.exports,\\n      <span class=hljs-built_in>module</span>,\\n      _my_webpack_require,\\n      <span class=hljs-built_in>module</span>.exports\\n    )\\n    <span class=hljs-keyword>return</span> <span class=hljs-built_in>module</span>.exports\\n  }\\n\\n  _my_webpack_require.d = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>exports, key, value</span>) </span>{\\n    exports[key] = value\\n  }\\n\\n  <span class=hljs-keyword>return</span> _my_webpack_require(<span class=hljs-string>\\"./src/a.js\\"</span>)\\n})({\\n  <span class=hljs-string>\\"./src/b.js\\"</span>: <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>module, _my_webpack_require, _my_webpack_export</span>) </span>{\\n    <span class=hljs-built_in>eval</span>(\\n      <span class=hljs-string>\\"_my_webpack_require.d(_my_webpack_export, \'a\', 123);_my_webpack_require.d(_my_webpack_export, \'default\', 456);\\"</span>\\n    )\\n  },\\n  <span class=hljs-string>\\"./src/a.js\\"</span>: <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>module, _my_webpack_require, _my_webpack_export</span>) </span>{\\n    <span class=hljs-built_in>eval</span>(\\n      <span class=hljs-string>\\"var _my_webpack_module_0 = _my_webpack_require(\'./src/b.js\');console.log(_my_webpack_module_0);\\"</span>\\n    )\\n  },\\n})</code></pre> </div>";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/webpack/%E7%94%A8babel%E6%9D%A5%E6%A8%A1%E6%8B%9Fwebpack%E7%9A%84%E7%BC%96%E8%AF%91%E5%AE%9E%E7%8E%B0.md?')},281:function(module,exports){eval('// Module\nvar code = "<div class=note-title><p>redux源码系列之中间件</p> <p>redux源码系列之中间件</p> </div><div class=note-content><p>redux工作的流程是总的来说是<code>dispatch</code>推送<code>action</code>进入<code>reducer</code>纯函数，进而改变<code>state</code>，并返回新的<code>state</code>状态。中间件的作用就是在流程进入<code>reducer</code>之前添加一些副作用，比如说处理异步请求，日志记录等任务。</p> <h3>中间件的使用</h3> <pre><code class=\\"hljs js\\"><span class=hljs-keyword>import</span> { applyMiddleware, createStore } <span class=hljs-keyword>from</span> <span class=hljs-string>\'redux\'</span>;\\n<span class=hljs-keyword>const</span> logger = <span class=hljs-function><span class=hljs-params>store</span> =&gt;</span> <span class=hljs-function><span class=hljs-params>next</span> =&gt;</span> <span class=hljs-function><span class=hljs-params>action</span> =&gt;</span> {\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\'is begin\'</span>);\\n  next(action);\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\'is end\'</span>);\\n}\\n<span class=hljs-keyword>const</span> doSomething = <span class=hljs-function><span class=hljs-params>store</span> =&gt;</span> <span class=hljs-function><span class=hljs-params>next</span> =&gt;</span> <span class=hljs-function><span class=hljs-params>action</span> =&gt;</span> {\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\'do something\'</span>);\\n  next(action);\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\'do something end\'</span>);\\n}\\n<span class=hljs-keyword>const</span> reducer = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>state, action</span>) </span>{\\n  <span class=hljs-keyword>const</span> newState = <span class=hljs-literal>null</span>;\\n  <span class=hljs-keyword>switch</span>(action.type) {\\n    <span class=hljs-keyword>case</span> <span class=hljs-string>\'DO_SOMETHING\'</span>:\\n      newState = action.value;\\n      <span class=hljs-keyword>break</span>;\\n    <span class=hljs-keyword>case</span> <span class=hljs-string>\'DO_ENDING\'</span>:\\n      newState = <span class=hljs-string>\'\'</span>;\\n      <span class=hljs-keyword>break</span>;\\n    <span class=hljs-keyword>default</span>:\\n      newState = state;\\n  }\\n  <span class=hljs-keyword>return</span> newState;\\n}\\n\\n<span class=hljs-keyword>const</span> store = createStore(reducer, applyMiddleware(logger, doSomething));</code></pre> <h3>中间件原理</h3> <pre><code class=\\"hljs js\\"><span class=hljs-comment>// 不使用中间件</span>\\n<span class=hljs-keyword>const</span> storeNoWare = createStore(reducer);\\n<span class=hljs-comment>// 使用中间件</span>\\n<span class=hljs-keyword>const</span> storeHasWare = createStore(reducer, applyMiddleware(logger, doSomething));</code></pre> <p>此例中的<code>storeNoWare</code>与<code>storeHasWare</code>都是对象，这两个对象拥有相同的key。</p> <table> <thead> <tr> <th>key</th> </tr> </thead> <tbody><tr> <td>dispatch</td> </tr> <tr> <td>subscribe</td> </tr> <tr> <td>getState</td> </tr> <tr> <td>replaceReducer</td> </tr> </tbody></table> <p>这个几个属性中dispatch在中间件中被重新代理成了其他内容，而其余则完全不变。</p> <p>下面是<code>applyMiddleware</code>的源码</p> <pre><code class=\\"hljs js\\"><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>applyMiddleware</span>(<span class=hljs-params>...middlewares</span>) </span>{\\n  <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-params>createStore</span> =&gt;</span> <span class=hljs-function>(<span class=hljs-params>...args</span>) =&gt;</span> {\\n    <span class=hljs-keyword>const</span> store = createStore(...args)\\n    <span class=hljs-keyword>let</span> dispatch = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> {\\n      <span class=hljs-keyword>throw</span> <span class=hljs-keyword>new</span> <span class=hljs-built_in>Error</span>(\\n        <span class=hljs-string>`Dispatching while constructing your middleware is not allowed. `</span> +\\n          <span class=hljs-string>`Other middleware would not be applied to this dispatch.`</span>\\n      )\\n    }\\n\\n    <span class=hljs-keyword>const</span> middlewareAPI = {\\n      <span class=hljs-attr>getState</span>: store.getState,\\n      <span class=hljs-attr>dispatch</span>: <span class=hljs-function>(<span class=hljs-params>...args</span>) =&gt;</span> dispatch(...args)\\n    }\\n    <span class=hljs-keyword>const</span> chain = middlewares.map(<span class=hljs-function><span class=hljs-params>middleware</span> =&gt;</span> middleware(middlewareAPI))\\n    dispatch = compose(...chain)(store.dispatch)\\n\\n    <span class=hljs-keyword>return</span> {\\n      ...store,\\n      dispatch\\n    }\\n  }\\n}</code></pre> <p>可以看出，<code>applyMiddleware</code>是一个高阶函数，它可以接受一系列的中间件，将各个中间件处理汇总，最后返回新的api。</p> <h3>中间价中对原本api的相关代理</h3> <p><code>applyMiddleware</code>的主要作用是重新执行<code>createStore</code>创建，与<code>dispatch</code>的代理</p> <blockquote> <p>对<code>createStore</code>的重新创建</p> </blockquote> <p>回顾一下<code>createStore</code>传入中间件的情况，在<code>createStore</code>创建过程中会执行这样一句代码：</p> <pre><code class=\\"hljs js\\"><span class=hljs-keyword>return</span> enhancer(createStore)(reducer, preloadedState)</code></pre> <p>可以看到在有中间件时，<code>createStore</code>函数在这里被返回，后续内容不再执行。而这里面的<code>enhancer</code>就是调用<code>applyMiddleware</code>后返回的高阶函数，从源码中可以看出这个高阶函数接受<code>createStore</code>函数作为参数，然后返回一个接受<code>reducer</code>和<code>preloadedState</code>的函数。 而最终，在<code>applyMiddleware</code>内部，<code>createStore</code>被重新执行，并返回无中间件时的执行结果。</p> <blockquote> <p>对<code>dispatch</code>的代理</p> </blockquote> <p>从<code>applyMiddleware</code>源码中可以看到，<code>dispatch</code>被重新赋值，而原本的<code>dispatch</code>被传入了中间件内部。</p> <pre><code class=\\"hljs js\\"><span class=hljs-keyword>const</span> chain = middlewares.map(<span class=hljs-function><span class=hljs-params>middleware</span> =&gt;</span> middleware(middlewareAPI))\\ndispatch = compose(...chain)(store.dispatch)</code></pre> <p>下面是一个中间件\\b定义，它是个一个高阶函数。</p> <pre><code class=\\"hljs js\\"><span class=hljs-keyword>const</span> logger = <span class=hljs-function><span class=hljs-params>store</span> =&gt;</span> <span class=hljs-function><span class=hljs-params>next</span> =&gt;</span> <span class=hljs-function><span class=hljs-params>action</span> =&gt;</span> {\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\'dispatching\'</span>, action)\\n  <span class=hljs-keyword>let</span> result = next(action)\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\'next state\'</span>, store.getState())\\n  <span class=hljs-keyword>return</span> result\\n}</code></pre> <p>下面细细拆分一下中间件在<code>applyMiddleware</code>执行过程。 第一步，所有传入<code>applyMiddleware</code>的中间件均在下面代码中执行一次最外层的函数</p> <pre><code class=\\"hljs js\\"><span class=hljs-keyword>const</span> chain = middlewares.map(<span class=hljs-function><span class=hljs-params>middleware</span> =&gt;</span> middleware(middlewareAPI))</code></pre> <p>第二步，所有中间件外层函数执行后，返回的函数被存入了变量<code>chain</code>中，之后<code>chain</code>又经过了<code>compose</code>处理。</p> <pre><code class=\\"hljs js\\"><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>compose</span>(<span class=hljs-params>...funcs</span>) </span>{\\n  <span class=hljs-keyword>if</span> (funcs.length === <span class=hljs-number>0</span>) {\\n    <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-params>arg</span> =&gt;</span> arg\\n  }\\n\\n  <span class=hljs-keyword>if</span> (funcs.length === <span class=hljs-number>1</span>) {\\n    <span class=hljs-keyword>return</span> funcs[<span class=hljs-number>0</span>]\\n  }\\n\\n  <span class=hljs-keyword>return</span> funcs.reduce(<span class=hljs-function>(<span class=hljs-params>a, b</span>) =&gt;</span> <span class=hljs-function>(<span class=hljs-params>...args</span>) =&gt;</span> a(b(...args)))\\n}</code></pre> <p>最终所有函数会被处理成这样的形式返回：</p> <pre><code class=\\"hljs js\\">(...args) =&gt; a(b(c(d(...args))));</code></pre> <p>再看下面代码：</p> <pre><code class=\\"hljs js\\">dispatch = compose(...chain)(store.dispatch)</code></pre> <p>其实际执行的就是上述被<code>compose</code>处理返回后的函数，这样每一个函数执行的结果作为它前面一个函数的实参传到函数内部，而且<code>dispatch</code>是被最后一个函数接受的。本次执行后所有高阶中间件函数只剩了一层函数，这个函数接受最终的<code>action</code>。</p> <p>最后一步，使用了中间件后，外界所得到的就是上步的最后一层函数，当使用<code>dispatch</code>时，<code>action</code>由外而内，最终传入接受真实<code>dispatch</code>的函数，触发<code>redux</code>状态改变。</p> <p><strong>自定义redux与中间件</strong></p> <pre><code class=\\"hljs js\\"><span class=hljs-keyword>const</span> store = {\\n  <span class=hljs-attr>values</span>: {},\\n  dispatch(action) {\\n    <span class=hljs-keyword>this</span>.reducers(action);\\n    <span class=hljs-keyword>this</span>.notify();\\n  },\\n  getState() {\\n    <span class=hljs-keyword>return</span> <span class=hljs-keyword>this</span>.values;\\n  },\\n  reducers(action) {\\n    <span class=hljs-keyword>this</span>.values[action.type] = action.value;\\n  },\\n  notify() {\\n    <span class=hljs-keyword>this</span>.listeners.forEach(<span class=hljs-function><span class=hljs-params>func</span> =&gt;</span> func(<span class=hljs-keyword>this</span>.getState()));\\n  },\\n  <span class=hljs-attr>listeners</span>: []\\n};\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>listenersOne</span>(<span class=hljs-params>values</span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(values);\\n}\\n\\nstore.listeners.push(listenersOne);\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>fa</span>(<span class=hljs-params>next</span>) </span>{\\n  <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>action</span>) </span>{\\n    next(action);\\n  };\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>fb</span>(<span class=hljs-params>next</span>) </span>{\\n  <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>action</span>) </span>{\\n    <span class=hljs-keyword>return</span> next(action);\\n  };\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>compose</span>(<span class=hljs-params>...args</span>) </span>{\\n  <span class=hljs-keyword>return</span> args.reduce(<span class=hljs-function>(<span class=hljs-params>a, b</span>) =&gt;</span> <span class=hljs-function>(<span class=hljs-params>...innerargs</span>) =&gt;</span> a(b(...innerargs)));\\n}\\n\\n<span class=hljs-keyword>const</span> dispatch = compose(\\n  fa,\\n  fb\\n)(store.dispatch.bind(store));\\n\\ndispatch({ <span class=hljs-attr>type</span>: <span class=hljs-string>\'add\'</span>, <span class=hljs-attr>value</span>: <span class=hljs-number>2</span> });</code></pre> </div>";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/react/redux/redux%E6%BA%90%E7%A0%81%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%AD%E9%97%B4%E4%BB%B6.md?')},282:function(module,exports){eval("// Module\nvar code = \"<div class=note-title><p>React源码分析之ReactElement</p> <p>ReactElement是React中的一些最基本接口，包括一个React对象的创建、拷贝与验证等。</p> </div><div class=note-content> <h3>接口api</h3> <p><code>ReactElement</code>提供了如下接口</p> <ul> <li><code>createElement</code></li> <li><code>createFactory</code></li> <li><code>cloneElement</code></li> <li><code>isValidElement</code></li> </ul> <p>在介绍这些接口前需要先看一下<code>ReactElement</code>中一个最根本的方法<code>ReactElement</code>，它定义了是<code>React</code>最基本东西，便是<code>React</code>对象基本构成。</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>const</span> ReactElement = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>type, key, ref, self, source, owner, props</span>) </span>{\\n  <span class=hljs-keyword>const</span> element = {\\n    <span class=hljs-comment>// This tag allows us to uniquely identify this as a React Element</span>\\n    <span class=hljs-attr>$$typeof</span>: REACT_ELEMENT_TYPE,\\n\\n    <span class=hljs-comment>// Built-in properties that belong on the element</span>\\n    <span class=hljs-attr>type</span>: type,\\n    <span class=hljs-attr>key</span>: key,\\n    <span class=hljs-attr>ref</span>: ref,\\n    <span class=hljs-attr>props</span>: props,\\n\\n    <span class=hljs-comment>// Record the component responsible for creating this element.</span>\\n    <span class=hljs-attr>_owner</span>: owner,\\n  };\\n\\n  <span class=hljs-keyword>if</span> (__DEV__) {\\n    <span class=hljs-comment>// The validation flag is currently mutative. We put it on</span>\\n    <span class=hljs-comment>// an external backing store so that we can freeze the whole object.</span>\\n    <span class=hljs-comment>// This can be replaced with a WeakMap once they are implemented in</span>\\n    <span class=hljs-comment>// commonly used development environments.</span>\\n    element._store = {};\\n\\n    <span class=hljs-comment>// To make comparing ReactElements easier for testing purposes, we make</span>\\n    <span class=hljs-comment>// the validation flag non-enumerable (where possible, which should</span>\\n    <span class=hljs-comment>// include every environment we run tests in), so the test framework</span>\\n    <span class=hljs-comment>// ignores it.</span>\\n    <span class=hljs-built_in>Object</span>.defineProperty(element._store, <span class=hljs-string>'validated'</span>, {\\n      <span class=hljs-attr>configurable</span>: <span class=hljs-literal>false</span>,\\n      <span class=hljs-attr>enumerable</span>: <span class=hljs-literal>false</span>,\\n      <span class=hljs-attr>writable</span>: <span class=hljs-literal>true</span>,\\n      <span class=hljs-attr>value</span>: <span class=hljs-literal>false</span>,\\n    });\\n    <span class=hljs-comment>// self and source are DEV only properties.</span>\\n    <span class=hljs-built_in>Object</span>.defineProperty(element, <span class=hljs-string>'_self'</span>, {\\n      <span class=hljs-attr>configurable</span>: <span class=hljs-literal>false</span>,\\n      <span class=hljs-attr>enumerable</span>: <span class=hljs-literal>false</span>,\\n      <span class=hljs-attr>writable</span>: <span class=hljs-literal>false</span>,\\n      <span class=hljs-attr>value</span>: self,\\n    });\\n    <span class=hljs-comment>// Two elements created in two different places should be considered</span>\\n    <span class=hljs-comment>// equal for testing purposes and therefore we hide it from enumeration.</span>\\n    <span class=hljs-built_in>Object</span>.defineProperty(element, <span class=hljs-string>'_source'</span>, {\\n      <span class=hljs-attr>configurable</span>: <span class=hljs-literal>false</span>,\\n      <span class=hljs-attr>enumerable</span>: <span class=hljs-literal>false</span>,\\n      <span class=hljs-attr>writable</span>: <span class=hljs-literal>false</span>,\\n      <span class=hljs-attr>value</span>: source,\\n    });\\n    <span class=hljs-keyword>if</span> (<span class=hljs-built_in>Object</span>.freeze) {\\n      <span class=hljs-built_in>Object</span>.freeze(element.props);\\n      <span class=hljs-built_in>Object</span>.freeze(element);\\n    }\\n  }\\n\\n  <span class=hljs-keyword>return</span> element;\\n};</code></pre> <h3>createElement</h3> <p><code>createElement</code>作用是创建一个<code>React</code>对象，在<code>React</code>中，无论以何种方式声明一个组件，最终都会转化成调用此函数创建一个<code>React</code>对象的形式，<code>createElement</code>接受三个参数，分别是</p> <ul> <li>type 组件类型</li> <li>config 组件所拥有的一些属性，比如<code>key</code>,<code>ref</code>等,<code>key</code>,<code>ref</code>最终会分别传给<code>ReactElement</code>中<code>React</code>对象所对应的部分，通常其余一些属性会被挂载到<code>React</code>对象的<code>props</code>(便是上面<code>ReactElement</code>定义的<code>props</code>)中</li> <li>children 顾名思义，第三个参数便是该React对象下的子元素，可以为其他<code>React对象</code>或者字符串等等类型。</li> </ul> <pre><code class=\\\"hljs js\\\">React.createElement(<span class=hljs-string>'div'</span>, <span class=hljs-literal>null</span>, <span class=hljs-string>'Hool Hool'</span>);\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>ReactDemo</span>(<span class=hljs-params>{content, children}</span>) </span>{\\n  <span class=hljs-keyword>return</span> (\\n    <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span>&gt;</span>\\n      {content}\\n      {children}\\n    <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span></span>\\n    );\\n}\\nReact.createElement(ReactDemo, {<span class=hljs-attr>content</span>: <span class=hljs-string>'Hool Hool'</span>}, <span class=hljs-string>'Hool Hool Children'</span>)；</code></pre> <p>在使用ES6语法以及JSX语法时，我们通常这样定义一个组件</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>import</span> React <span class=hljs-keyword>from</span> <span class=hljs-string>'react'</span>;\\n<span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>ReactDemo</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{\\n    render() {\\n        <span class=hljs-keyword>const</span> { content, children } = <span class=hljs-keyword>this</span>.props;\\n        <span class=hljs-keyword>return</span> (\\n            <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span>&gt;</span>\\n                {content}\\n                {children}\\n            <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span></span>\\n        );\\n    }\\n}</code></pre> <p>使用上面这个组件</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>import</span> React, { Component } <span class=hljs-keyword>from</span> <span class=hljs-string>'react'</span>;\\n<span class=hljs-keyword>import</span> logo <span class=hljs-keyword>from</span> <span class=hljs-string>'./logo.svg'</span>;\\n<span class=hljs-keyword>import</span> <span class=hljs-string>'./App.css'</span>;\\n<span class=hljs-keyword>import</span> ReactDemo <span class=hljs-keyword>from</span> <span class=hljs-string>'./example'</span>;\\n<span class=hljs-comment>// 使用createElement创建React对象</span>\\n<span class=hljs-keyword>const</span> Demo = React.createElement(ReactDemo, {<span class=hljs-attr>content</span>: <span class=hljs-string>'Hool Hool'</span>},<span class=hljs-string>'Hool Children'</span>)\\n\\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>App</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>Component</span> </span>{\\n  render() {\\n    <span class=hljs-keyword>return</span> (\\n      <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>className</span>=<span class=hljs-string>\\\"App\\\"</span>&gt;</span>\\n        {/*使用Jsx语法*/}\\n        <span class=hljs-tag>&lt;<span class=hljs-name>ReactDemo</span> <span class=hljs-attr>content</span>=<span class=hljs-string>'Hool Jsx'</span>&gt;</span>\\n          'Hool Jsx Children'\\n        <span class=hljs-tag>&lt;/<span class=hljs-name>ReactDemo</span>&gt;</span>\\n        {Demo}\\n      <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span></span>\\n    );\\n  }\\n}\\n<span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> App;</code></pre> <p>上例中使用<code>createElement</code>与<code>Jsx</code>语法结果是一样的，就像上面所说的：使用<code>Jsx</code>最终也会被相应的<code>babel</code>转换为<code>createElement</code>创建形式</p> <ul> <li><code>createElement</code>函数源码</li> </ul> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createElement</span>(<span class=hljs-params>type, config, children</span>) </span>{\\n  <span class=hljs-keyword>let</span> propName;\\n\\n  <span class=hljs-comment>// Reserved names are extracted</span>\\n  <span class=hljs-keyword>const</span> props = {};\\n\\n  <span class=hljs-keyword>let</span> key = <span class=hljs-literal>null</span>;\\n  <span class=hljs-keyword>let</span> ref = <span class=hljs-literal>null</span>;\\n  <span class=hljs-keyword>let</span> self = <span class=hljs-literal>null</span>;\\n  <span class=hljs-keyword>let</span> source = <span class=hljs-literal>null</span>;\\n\\n  <span class=hljs-keyword>if</span> (config != <span class=hljs-literal>null</span>) {\\n    <span class=hljs-keyword>if</span> (hasValidRef(config)) {\\n      ref = config.ref;\\n    }\\n    <span class=hljs-keyword>if</span> (hasValidKey(config)) {\\n      key = <span class=hljs-string>''</span> + config.key;\\n    }\\n\\n    self = config.__self === <span class=hljs-literal>undefined</span> ? <span class=hljs-literal>null</span> : config.__self;\\n    source = config.__source === <span class=hljs-literal>undefined</span> ? <span class=hljs-literal>null</span> : config.__source;\\n    <span class=hljs-comment>// Remaining properties are added to a new props object</span>\\n    <span class=hljs-keyword>for</span> (propName <span class=hljs-keyword>in</span> config) {\\n      <span class=hljs-keyword>if</span> (\\n        hasOwnProperty.call(config, propName) &amp;&amp;\\n        !RESERVED_PROPS.hasOwnProperty(propName)\\n      ) {\\n        props[propName] = config[propName];\\n      }\\n    }\\n  }\\n\\n  <span class=hljs-comment>// Children can be more than one argument, and those are transferred onto</span>\\n  <span class=hljs-comment>// the newly allocated props object.</span>\\n  <span class=hljs-keyword>const</span> childrenLength = <span class=hljs-built_in>arguments</span>.length - <span class=hljs-number>2</span>;\\n  <span class=hljs-keyword>if</span> (childrenLength === <span class=hljs-number>1</span>) {\\n    props.children = children;\\n  } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (childrenLength &gt; <span class=hljs-number>1</span>) {\\n    <span class=hljs-keyword>const</span> childArray = <span class=hljs-built_in>Array</span>(childrenLength);\\n    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> i = <span class=hljs-number>0</span>; i &lt; childrenLength; i++) {\\n      childArray[i] = <span class=hljs-built_in>arguments</span>[i + <span class=hljs-number>2</span>];\\n    }\\n    <span class=hljs-keyword>if</span> (__DEV__) {\\n      <span class=hljs-keyword>if</span> (<span class=hljs-built_in>Object</span>.freeze) {\\n        <span class=hljs-built_in>Object</span>.freeze(childArray);\\n      }\\n    }\\n    props.children = childArray;\\n  }\\n\\n  <span class=hljs-comment>// Resolve default props</span>\\n  <span class=hljs-keyword>if</span> (type &amp;&amp; type.defaultProps) {\\n    <span class=hljs-keyword>const</span> defaultProps = type.defaultProps;\\n    <span class=hljs-keyword>for</span> (propName <span class=hljs-keyword>in</span> defaultProps) {\\n      <span class=hljs-keyword>if</span> (props[propName] === <span class=hljs-literal>undefined</span>) {\\n        props[propName] = defaultProps[propName];\\n      }\\n    }\\n  }\\n  <span class=hljs-keyword>if</span> (__DEV__) {\\n    <span class=hljs-keyword>if</span> (key || ref) {\\n      <span class=hljs-keyword>const</span> displayName =\\n        <span class=hljs-keyword>typeof</span> type === <span class=hljs-string>'function'</span>\\n          ? type.displayName || type.name || <span class=hljs-string>'Unknown'</span>\\n          : type;\\n      <span class=hljs-keyword>if</span> (key) {\\n        defineKeyPropWarningGetter(props, displayName);\\n      }\\n      <span class=hljs-keyword>if</span> (ref) {\\n        defineRefPropWarningGetter(props, displayName);\\n      }\\n    }\\n  }\\n  <span class=hljs-keyword>return</span> ReactElement(\\n    type,\\n    key,\\n    ref,\\n    self,\\n    source,\\n    ReactCurrentOwner.current,\\n    props,\\n  );\\n}</code></pre> <h3>cloneElement</h3> <ul> <li><p>用法</p> <pre><code class=\\\"hljs js\\\">React.cloneElement(element, props, children);</code></pre> <p><code>cloneElement</code>复制<code>React</code>组件，它的实现也十分简单，就是将要复制的组件以及props等相关属性系数拆分再合并形成新的<code>props</code>和<code>children</code>并再调用<code>cloneElement</code>，形成新的<code>React</code>对象</p> </li> <li><p><code>cloneElement</code>源码</p> </li> </ul> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>cloneElement</span>(<span class=hljs-params>element, config, children</span>) </span>{\\n  invariant(\\n    !(element === <span class=hljs-literal>null</span> || element === <span class=hljs-literal>undefined</span>),\\n    <span class=hljs-string>'React.cloneElement(...): The argument must be a React element, but you passed %s.'</span>,\\n    element,\\n  );\\n\\n  <span class=hljs-keyword>let</span> propName;\\n\\n  <span class=hljs-comment>// Original props are copied</span>\\n  <span class=hljs-keyword>const</span> props = <span class=hljs-built_in>Object</span>.assign({}, element.props);\\n\\n  <span class=hljs-comment>// Reserved names are extracted</span>\\n  <span class=hljs-keyword>let</span> key = element.key;\\n  <span class=hljs-keyword>let</span> ref = element.ref;\\n  <span class=hljs-comment>// Self is preserved since the owner is preserved.</span>\\n  <span class=hljs-keyword>const</span> self = element._self;\\n  <span class=hljs-comment>// Source is preserved since cloneElement is unlikely to be targeted by a</span>\\n  <span class=hljs-comment>// transpiler, and the original source is probably a better indicator of the</span>\\n  <span class=hljs-comment>// true owner.</span>\\n  <span class=hljs-keyword>const</span> source = element._source;\\n\\n  <span class=hljs-comment>// Owner will be preserved, unless ref is overridden</span>\\n  <span class=hljs-keyword>let</span> owner = element._owner;\\n\\n  <span class=hljs-keyword>if</span> (config != <span class=hljs-literal>null</span>) {\\n    <span class=hljs-keyword>if</span> (hasValidRef(config)) {\\n      <span class=hljs-comment>// Silently steal the ref from the parent.</span>\\n      ref = config.ref;\\n      owner = ReactCurrentOwner.current;\\n    }\\n    <span class=hljs-keyword>if</span> (hasValidKey(config)) {\\n      key = <span class=hljs-string>''</span> + config.key;\\n    }\\n\\n    <span class=hljs-comment>// Remaining properties override existing props</span>\\n    <span class=hljs-keyword>let</span> defaultProps;\\n    <span class=hljs-keyword>if</span> (element.type &amp;&amp; element.type.defaultProps) {\\n      defaultProps = element.type.defaultProps;\\n    }\\n    <span class=hljs-keyword>for</span> (propName <span class=hljs-keyword>in</span> config) {\\n      <span class=hljs-keyword>if</span> (\\n        hasOwnProperty.call(config, propName) &amp;&amp;\\n        !RESERVED_PROPS.hasOwnProperty(propName)\\n      ) {\\n        <span class=hljs-keyword>if</span> (config[propName] === <span class=hljs-literal>undefined</span> &amp;&amp; defaultProps !== <span class=hljs-literal>undefined</span>) {\\n          <span class=hljs-comment>// Resolve default props</span>\\n          props[propName] = defaultProps[propName];\\n        } <span class=hljs-keyword>else</span> {\\n          props[propName] = config[propName];\\n        }\\n      }\\n    }\\n  }\\n\\n  <span class=hljs-comment>// Children can be more than one argument, and those are transferred onto</span>\\n  <span class=hljs-comment>// the newly allocated props object.</span>\\n  <span class=hljs-keyword>const</span> childrenLength = <span class=hljs-built_in>arguments</span>.length - <span class=hljs-number>2</span>;\\n  <span class=hljs-keyword>if</span> (childrenLength === <span class=hljs-number>1</span>) {\\n    props.children = children;\\n  } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (childrenLength &gt; <span class=hljs-number>1</span>) {\\n    <span class=hljs-keyword>const</span> childArray = <span class=hljs-built_in>Array</span>(childrenLength);\\n    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>let</span> i = <span class=hljs-number>0</span>; i &lt; childrenLength; i++) {\\n      childArray[i] = <span class=hljs-built_in>arguments</span>[i + <span class=hljs-number>2</span>];\\n    }\\n    props.children = childArray;\\n  }\\n\\n  <span class=hljs-keyword>return</span> ReactElement(element.type, key, ref, self, source, owner, props);\\n}</code></pre> <h3>isValidElement</h3> <p><code>isValidElement</code>校验是否是<code>React</code>对象，这个实现便更简单了，创建<code>React</code>对象时，会增加一个<code>$$typeof</code>属性，这个属性用来标记<code>React</code>对象</p> <ul> <li>源码部分<pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>isValidElement</span>(<span class=hljs-params>object</span>) </span>{\\n<span class=hljs-keyword>return</span> (\\n  <span class=hljs-keyword>typeof</span> object === <span class=hljs-string>'object'</span> &amp;&amp;\\n  object !== <span class=hljs-literal>null</span> &amp;&amp;\\n  object.$$<span class=hljs-keyword>typeof</span> === REACT_ELEMENT_TYPE\\n);\\n}</code></pre> </li> </ul> <p>其中<code>REACT_ELEMENT_TYPE</code>为</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>const</span> hasSymbol = <span class=hljs-keyword>typeof</span> <span class=hljs-built_in>Symbol</span> === <span class=hljs-string>'function'</span> &amp;&amp; <span class=hljs-built_in>Symbol</span>.for;\\n<span class=hljs-keyword>export</span> <span class=hljs-keyword>const</span> REACT_ELEMENT_TYPE = hasSymbol\\n  ? <span class=hljs-built_in>Symbol</span>.for(<span class=hljs-string>'react.element'</span>)\\n  : <span class=hljs-number>0xeac7</span>;</code></pre> </div>\";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/react/source_code/React%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BReactElement.md?")},283:function(module,exports){eval('// Module\nvar code = "<div class=note-title><p>从setState的异步与同步来解析React的状态机制</p> <p>从setState的异步与同步来解析React的状态机制</p> </div><div class=note-content><p>Demo1 state错误式使用，最终结果counter为1</p> <pre><code class=\\"hljs js\\"><span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Demo</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{\\n    <span class=hljs-keyword>constructor</span>() {\\n        <span class=hljs-keyword>this</span>.state = { <span class=hljs-attr>counter</span>: <span class=hljs-number>0</span> }\\n    }\\n    componentDidMount() {\\n        <span class=hljs-keyword>this</span>.setState({ <span class=hljs-attr>counter</span>: <span class=hljs-keyword>this</span>.state.counter + <span class=hljs-number>1</span> });\\n        <span class=hljs-keyword>this</span>.setState({ <span class=hljs-attr>counter</span>: <span class=hljs-keyword>this</span>.state.counter + <span class=hljs-number>1</span> });\\n        <span class=hljs-keyword>this</span>.setState({ <span class=hljs-attr>counter</span>: <span class=hljs-keyword>this</span>.state.counter + <span class=hljs-number>1</span> });\\n    }\\n    render() {\\n        <span class=hljs-keyword>return</span> <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span>&gt;</span>{ this.state.counter }<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span></span>\\n    }\\n}</code></pre> <p>Demo2 state正确式回调函数,最终显示counter值为3</p> <pre><code class=\\"hljs js\\"><span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Demo</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{\\n    <span class=hljs-keyword>constructor</span>() {\\n        <span class=hljs-keyword>this</span>.state = { <span class=hljs-attr>counter</span>: <span class=hljs-number>0</span> }\\n    }\\n    componentDidMount() {\\n        <span class=hljs-keyword>this</span>.setState(<span class=hljs-function><span class=hljs-params>state</span> =&gt;</span> ({<span class=hljs-attr>counter</span>: state.counter + <span class=hljs-number>1</span>}));\\n        <span class=hljs-keyword>this</span>.setState(<span class=hljs-function><span class=hljs-params>state</span> =&gt;</span> ({<span class=hljs-attr>counter</span>: state.counter + <span class=hljs-number>1</span>}));\\n        <span class=hljs-keyword>this</span>.setState(<span class=hljs-function><span class=hljs-params>state</span> =&gt;</span> ({<span class=hljs-attr>counter</span>: state.counter + <span class=hljs-number>1</span>}));\\n    }\\n    render() {\\n        <span class=hljs-keyword>return</span> <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span>&gt;</span>{ this.state.counter }<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span></span>\\n    }\\n}</code></pre> <p>分析</p> <p>1、为何会出现Demo1与Demo2的结果，state是异步的么？</p> <p>2、在异步（例如setTimeout）与事件中state表现是同步还是异步？</p> <p>3、理解<a href=https://zh-hans.reactjs.org/docs/state-and-lifecycle.html>官网</a>中指出this.props 和 this.state 可能会异步更新，所以不要依赖他们的值来更新下一个状态，这个异步更新原理</p> <pre><code class=\\"hljs js\\"><span class=hljs-comment>// Wrong</span>\\n<span class=hljs-keyword>this</span>.setState({\\n  <span class=hljs-attr>counter</span>: <span class=hljs-keyword>this</span>.state.counter + <span class=hljs-keyword>this</span>.props.increment,\\n});\\n\\n\\n<span class=hljs-comment>// Correct</span>\\n<span class=hljs-keyword>this</span>.setState(<span class=hljs-function>(<span class=hljs-params>state, props</span>) =&gt;</span> ({\\n  <span class=hljs-attr>counter</span>: state.counter + props.increment\\n}));</code></pre> </div>";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/react/source_code/%E4%BB%8EsetState%E7%9A%84%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%E6%9D%A5%E8%A7%A3%E6%9E%90React%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E5%88%B6.md?')},284:function(module,exports){eval("// Module\nvar code = \"<div class=note-title><p>react-redux介绍</p> <p>react-redux本质上是一个作为react与redux之间联系的桥梁，它在监听redux状态变化，一旦redux更新，监听生效，新的数据状态就会被react-redux获取，从而react组件</p> </div><div class=note-content><p>相关API与源码展示</p> <p>1、Provider，react组件，将redux创建成功后返回的store对象绑定在上下文上，以便子组件使用</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createProvider</span>(<span class=hljs-params>storeKey = <span class=hljs-string>'store'</span></span>) </span>{\\n    <span class=hljs-keyword>const</span> subscriptionKey = <span class=hljs-string>`<span class=hljs-subst>${storeKey}</span>Subscription`</span>\\n\\n    <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Provider</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>Component</span> </span>{\\n        getChildContext() {\\n          <span class=hljs-keyword>return</span> { [storeKey]: <span class=hljs-keyword>this</span>[storeKey], [subscriptionKey]: <span class=hljs-literal>null</span> }\\n        }\\n\\n        <span class=hljs-keyword>constructor</span>(props, context) {\\n          <span class=hljs-keyword>super</span>(props, context)\\n          <span class=hljs-keyword>this</span>[storeKey] = props.store;\\n        }\\n\\n        render() {\\n          <span class=hljs-keyword>return</span> Children.only(<span class=hljs-keyword>this</span>.props.children)\\n        }\\n    }\\n\\n    <span class=hljs-keyword>if</span> (process.env.NODE_ENV !== <span class=hljs-string>'production'</span>) {\\n      Provider.prototype.componentWillReceiveProps = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>nextProps</span>) </span>{\\n        <span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>[storeKey] !== nextProps.store) {\\n          warnAboutReceivingStore()\\n        }\\n      }\\n    }\\n\\n    Provider.propTypes = {\\n        <span class=hljs-attr>store</span>: storeShape.isRequired,\\n        <span class=hljs-attr>children</span>: PropTypes.element.isRequired,\\n    }\\n    Provider.childContextTypes = {\\n        [storeKey]: storeShape.isRequired,\\n        [subscriptionKey]: subscriptionShape,\\n    }\\n\\n    <span class=hljs-keyword>return</span> Provider\\n}</code></pre> <p>2、connect 高阶组件，将redux状态映射到react组件上</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>export</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>createConnect</span>(<span class=hljs-params>{\\n  connectHOC = connectAdvanced,\\n  mapStateToPropsFactories = defaultMapStateToPropsFactories,\\n  mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories,\\n  mergePropsFactories = defaultMergePropsFactories,\\n  selectorFactory = defaultSelectorFactory\\n} = {}</span>) </span>{\\n  <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>connect</span>(<span class=hljs-params>\\n    mapStateToProps,\\n    mapDispatchToProps,\\n    mergeProps,\\n    {\\n      pure = true,\\n      areStatesEqual = strictEqual,\\n      areOwnPropsEqual = shallowEqual,\\n      areStatePropsEqual = shallowEqual,\\n      areMergedPropsEqual = shallowEqual,\\n      ...extraOptions\\n    } = {}\\n  </span>) </span>{\\n    <span class=hljs-keyword>const</span> initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, <span class=hljs-string>'mapStateToProps'</span>)\\n    <span class=hljs-keyword>const</span> initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, <span class=hljs-string>'mapDispatchToProps'</span>)\\n    <span class=hljs-keyword>const</span> initMergeProps = match(mergeProps, mergePropsFactories, <span class=hljs-string>'mergeProps'</span>)\\n\\n    <span class=hljs-keyword>return</span> connectHOC(selectorFactory, {\\n      <span class=hljs-comment>// used in error messages</span>\\n      <span class=hljs-attr>methodName</span>: <span class=hljs-string>'connect'</span>,\\n\\n       <span class=hljs-comment>// used to compute Connect's displayName from the wrapped component's displayName.</span>\\n      <span class=hljs-attr>getDisplayName</span>: <span class=hljs-function><span class=hljs-params>name</span> =&gt;</span> <span class=hljs-string>`Connect(<span class=hljs-subst>${name}</span>)`</span>,\\n\\n      <span class=hljs-comment>// if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes</span>\\n      <span class=hljs-attr>shouldHandleStateChanges</span>: <span class=hljs-built_in>Boolean</span>(mapStateToProps),\\n\\n      <span class=hljs-comment>// passed through to selectorFactory</span>\\n      initMapStateToProps,\\n      initMapDispatchToProps,\\n      initMergeProps,\\n      pure,\\n      areStatesEqual,\\n      areOwnPropsEqual,\\n      areStatePropsEqual,\\n      areMergedPropsEqual,\\n\\n      <span class=hljs-comment>// any extra options args can override defaults of connect or connectAdvanced</span>\\n      ...extraOptions\\n    })\\n  }\\n}</code></pre> <p>实现与react组件与redux状态捆绑的功能主要集中在connectHOC（connectAdvanced）方法中</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>connectAdvanced</span>(<span class=hljs-params>\\n  selectorFactory,\\n  <span class=hljs-regexp>//</span> options object:\\n  {\\n    getDisplayName = name =&gt; <span class=hljs-string>`ConnectAdvanced(<span class=hljs-subst>${name}</span>)`</span>,\\n    methodName = <span class=hljs-string>'connectAdvanced'</span>,\\n    renderCountProp = undefined,\\n    shouldHandleStateChanges = true,\\n    storeKey = <span class=hljs-string>'store'</span>,\\n    withRef = false,\\n    ...connectOptions\\n  } = {}\\n</span>) </span>{\\n  <span class=hljs-keyword>const</span> subscriptionKey = storeKey + <span class=hljs-string>'Subscription'</span>\\n  <span class=hljs-keyword>const</span> version = hotReloadingVersion++\\n\\n  <span class=hljs-keyword>const</span> contextTypes = {\\n    [storeKey]: storeShape,\\n    [subscriptionKey]: subscriptionShape,\\n  }\\n  <span class=hljs-keyword>const</span> childContextTypes = {\\n    [subscriptionKey]: subscriptionShape,\\n  }\\n\\n  <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>wrapWithConnect</span>(<span class=hljs-params>WrappedComponent</span>) </span>{\\n    invariant(\\n      <span class=hljs-keyword>typeof</span> WrappedComponent == <span class=hljs-string>'function'</span>,\\n      <span class=hljs-string>`You must pass a component to the function returned by `</span> +\\n      <span class=hljs-string>`<span class=hljs-subst>${methodName}</span>. Instead received <span class=hljs-subst>${<span class=hljs-built_in>JSON</span>.stringify(WrappedComponent)}</span>`</span>\\n    )\\n\\n    <span class=hljs-keyword>const</span> wrappedComponentName = WrappedComponent.displayName\\n      || WrappedComponent.name\\n      || <span class=hljs-string>'Component'</span>\\n\\n    <span class=hljs-keyword>const</span> displayName = getDisplayName(wrappedComponentName)\\n\\n    <span class=hljs-keyword>const</span> selectorFactoryOptions = {\\n      ...connectOptions,\\n      getDisplayName,\\n      methodName,\\n      renderCountProp,\\n      shouldHandleStateChanges,\\n      storeKey,\\n      withRef,\\n      displayName,\\n      wrappedComponentName,\\n      WrappedComponent\\n    }\\n\\n    <span class=hljs-comment>// TODO Actually fix our use of componentWillReceiveProps</span>\\n    <span class=hljs-comment>/* eslint-disable react/no-deprecated */</span>\\n\\n    <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Connect</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>Component</span> </span>{\\n      <span class=hljs-keyword>constructor</span>(props, context) {\\n        <span class=hljs-keyword>super</span>(props, context)\\n\\n        <span class=hljs-keyword>this</span>.version = version\\n        <span class=hljs-keyword>this</span>.state = {}\\n        <span class=hljs-keyword>this</span>.renderCount = <span class=hljs-number>0</span>\\n        <span class=hljs-keyword>this</span>.store = props[storeKey] || context[storeKey]\\n        <span class=hljs-keyword>this</span>.propsMode = <span class=hljs-built_in>Boolean</span>(props[storeKey])\\n        <span class=hljs-keyword>this</span>.setWrappedInstance = <span class=hljs-keyword>this</span>.setWrappedInstance.bind(<span class=hljs-keyword>this</span>)\\n\\n        invariant(<span class=hljs-keyword>this</span>.store,\\n          <span class=hljs-string>`Could not find \\\"<span class=hljs-subst>${storeKey}</span>\\\" in either the context or props of `</span> +\\n          <span class=hljs-string>`\\\"<span class=hljs-subst>${displayName}</span>\\\". Either wrap the root component in a &lt;Provider&gt;, `</span> +\\n          <span class=hljs-string>`or explicitly pass \\\"<span class=hljs-subst>${storeKey}</span>\\\" as a prop to \\\"<span class=hljs-subst>${displayName}</span>\\\".`</span>\\n        )\\n\\n        <span class=hljs-keyword>this</span>.initSelector()\\n        <span class=hljs-keyword>this</span>.initSubscription()\\n      }\\n\\n      getChildContext() {\\n        <span class=hljs-keyword>const</span> subscription = <span class=hljs-keyword>this</span>.propsMode ? <span class=hljs-literal>null</span> : <span class=hljs-keyword>this</span>.subscription\\n        <span class=hljs-keyword>return</span> { [subscriptionKey]: subscription || <span class=hljs-keyword>this</span>.context[subscriptionKey] }\\n      }\\n\\n      componentDidMount() {\\n        <span class=hljs-keyword>if</span> (!shouldHandleStateChanges) <span class=hljs-keyword>return</span>\\n\\n        <span class=hljs-keyword>this</span>.subscription.trySubscribe()\\n        <span class=hljs-keyword>this</span>.selector.run(<span class=hljs-keyword>this</span>.props)\\n        <span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>.selector.shouldComponentUpdate) <span class=hljs-keyword>this</span>.forceUpdate()\\n      }\\n\\n      componentWillReceiveProps(nextProps) {\\n        <span class=hljs-keyword>this</span>.selector.run(nextProps)\\n      }\\n\\n      shouldComponentUpdate() {\\n        <span class=hljs-keyword>return</span> <span class=hljs-keyword>this</span>.selector.shouldComponentUpdate\\n      }\\n\\n      componentWillUnmount() {\\n        <span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>.subscription) <span class=hljs-keyword>this</span>.subscription.tryUnsubscribe()\\n        <span class=hljs-keyword>this</span>.subscription = <span class=hljs-literal>null</span>\\n        <span class=hljs-keyword>this</span>.notifyNestedSubs = noop\\n        <span class=hljs-keyword>this</span>.store = <span class=hljs-literal>null</span>\\n        <span class=hljs-keyword>this</span>.selector.run = noop\\n        <span class=hljs-keyword>this</span>.selector.shouldComponentUpdate = <span class=hljs-literal>false</span>\\n      }\\n\\n      getWrappedInstance() {\\n        invariant(withRef,\\n          <span class=hljs-string>`To access the wrapped instance, you need to specify `</span> +\\n          <span class=hljs-string>`{ withRef: true } in the options argument of the <span class=hljs-subst>${methodName}</span>() call.`</span>\\n        )\\n        <span class=hljs-keyword>return</span> <span class=hljs-keyword>this</span>.wrappedInstance\\n      }\\n\\n      setWrappedInstance(ref) {\\n        <span class=hljs-keyword>this</span>.wrappedInstance = ref\\n      }\\n\\n      initSelector() {\\n        <span class=hljs-keyword>const</span> sourceSelector = selectorFactory(<span class=hljs-keyword>this</span>.store.dispatch, selectorFactoryOptions)\\n        <span class=hljs-keyword>this</span>.selector = makeSelectorStateful(sourceSelector, <span class=hljs-keyword>this</span>.store)\\n        <span class=hljs-keyword>this</span>.selector.run(<span class=hljs-keyword>this</span>.props)\\n      }\\n\\n      initSubscription() {\\n        <span class=hljs-keyword>if</span> (!shouldHandleStateChanges) <span class=hljs-keyword>return</span>\\n\\n        <span class=hljs-keyword>const</span> parentSub = (<span class=hljs-keyword>this</span>.propsMode ? <span class=hljs-keyword>this</span>.props : <span class=hljs-keyword>this</span>.context)[subscriptionKey]\\n        <span class=hljs-keyword>this</span>.subscription = <span class=hljs-keyword>new</span> Subscription(<span class=hljs-keyword>this</span>.store, parentSub, <span class=hljs-keyword>this</span>.onStateChange.bind(<span class=hljs-keyword>this</span>))\\n\\n        <span class=hljs-keyword>this</span>.notifyNestedSubs = <span class=hljs-keyword>this</span>.subscription.notifyNestedSubs.bind(<span class=hljs-keyword>this</span>.subscription)\\n      }\\n\\n      onStateChange() {\\n        <span class=hljs-keyword>this</span>.selector.run(<span class=hljs-keyword>this</span>.props)\\n\\n        <span class=hljs-keyword>if</span> (!<span class=hljs-keyword>this</span>.selector.shouldComponentUpdate) {\\n          <span class=hljs-keyword>this</span>.notifyNestedSubs()\\n        } <span class=hljs-keyword>else</span> {\\n          <span class=hljs-keyword>this</span>.componentDidUpdate = <span class=hljs-keyword>this</span>.notifyNestedSubsOnComponentDidUpdate\\n          <span class=hljs-keyword>this</span>.setState(dummyState)\\n        }\\n      }\\n\\n      notifyNestedSubsOnComponentDidUpdate() {\\n        <span class=hljs-keyword>this</span>.componentDidUpdate = <span class=hljs-literal>undefined</span>\\n        <span class=hljs-keyword>this</span>.notifyNestedSubs()\\n      }\\n\\n      isSubscribed() {\\n        <span class=hljs-keyword>return</span> <span class=hljs-built_in>Boolean</span>(<span class=hljs-keyword>this</span>.subscription) &amp;&amp; <span class=hljs-keyword>this</span>.subscription.isSubscribed()\\n      }\\n\\n      addExtraProps(props) {\\n        <span class=hljs-keyword>if</span> (!withRef &amp;&amp; !renderCountProp &amp;&amp; !(<span class=hljs-keyword>this</span>.propsMode &amp;&amp; <span class=hljs-keyword>this</span>.subscription)) <span class=hljs-keyword>return</span> props\\n\\n        <span class=hljs-keyword>const</span> withExtras = { ...props }\\n        <span class=hljs-keyword>if</span> (withRef) withExtras.ref = <span class=hljs-keyword>this</span>.setWrappedInstance\\n        <span class=hljs-keyword>if</span> (renderCountProp) withExtras[renderCountProp] = <span class=hljs-keyword>this</span>.renderCount++\\n        <span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>.propsMode &amp;&amp; <span class=hljs-keyword>this</span>.subscription) withExtras[subscriptionKey] = <span class=hljs-keyword>this</span>.subscription\\n        <span class=hljs-keyword>return</span> withExtras\\n      }\\n\\n      render() {\\n        <span class=hljs-keyword>const</span> selector = <span class=hljs-keyword>this</span>.selector\\n        selector.shouldComponentUpdate = <span class=hljs-literal>false</span>\\n\\n        <span class=hljs-keyword>if</span> (selector.error) {\\n          <span class=hljs-keyword>throw</span> selector.error\\n        } <span class=hljs-keyword>else</span> {\\n          <span class=hljs-keyword>return</span> createElement(WrappedComponent, <span class=hljs-keyword>this</span>.addExtraProps(selector.props))\\n        }\\n      }\\n    }\\n\\n    <span class=hljs-comment>/* eslint-enable react/no-deprecated */</span>\\n\\n    Connect.WrappedComponent = WrappedComponent\\n    Connect.displayName = displayName\\n    Connect.childContextTypes = childContextTypes\\n    Connect.contextTypes = contextTypes\\n    Connect.propTypes = contextTypes\\n\\n    <span class=hljs-keyword>if</span> (process.env.NODE_ENV !== <span class=hljs-string>'production'</span>) {\\n      Connect.prototype.componentWillUpdate = <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>componentWillUpdate</span>(<span class=hljs-params></span>) </span>{\\n        <span class=hljs-comment>// We are hot reloading!</span>\\n        <span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>.version !== version) {\\n          <span class=hljs-keyword>this</span>.version = version\\n          <span class=hljs-keyword>this</span>.initSelector()\\n\\n          <span class=hljs-keyword>let</span> oldListeners = [];\\n\\n          <span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>.subscription) {\\n            oldListeners = <span class=hljs-keyword>this</span>.subscription.listeners.get()\\n            <span class=hljs-keyword>this</span>.subscription.tryUnsubscribe()\\n          }\\n          <span class=hljs-keyword>this</span>.initSubscription()\\n          <span class=hljs-keyword>if</span> (shouldHandleStateChanges) {\\n            <span class=hljs-keyword>this</span>.subscription.trySubscribe()\\n            oldListeners.forEach(<span class=hljs-function><span class=hljs-params>listener</span> =&gt;</span> <span class=hljs-keyword>this</span>.subscription.listeners.subscribe(listener))\\n          }\\n        }\\n      }\\n    }\\n\\n    <span class=hljs-keyword>return</span> hoistStatics(Connect, WrappedComponent)\\n  }\\n}</code></pre> <p>在高阶组件connectAdvanced被初始化过程时，initSubscription函数被调用，而对redux状态监听的绑定过程就是在这个函数调用时发生的</p> <pre><code class=\\\"hljs js\\\">initSubscription() {\\n <span class=hljs-keyword>if</span> (!shouldHandleStateChanges) <span class=hljs-keyword>return</span>\\n\\n <span class=hljs-keyword>const</span> parentSub = (<span class=hljs-keyword>this</span>.propsMode ? <span class=hljs-keyword>this</span>.props : <span class=hljs-keyword>this</span>.context)[subscriptionKey]\\n <span class=hljs-keyword>this</span>.subscription = <span class=hljs-keyword>new</span> Subscription(<span class=hljs-keyword>this</span>.store, parentSub, <span class=hljs-keyword>this</span>.onStateChange.bind(<span class=hljs-keyword>this</span>))\\n <span class=hljs-keyword>this</span>.notifyNestedSubs = <span class=hljs-keyword>this</span>.subscription.notifyNestedSubs.bind(<span class=hljs-keyword>this</span>.subscription)\\n}\\n</code></pre> <p>connectAdvanced中提供了onStateChange，这个方法就是用来监听redux状态变化的，并最终通过Subscription类完成监听绑定</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>export</span> <span class=hljs-keyword>default</span> <span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>Subscription</span> </span>{\\n  <span class=hljs-keyword>constructor</span>(store, parentSub, onStateChange) {\\n    <span class=hljs-keyword>this</span>.store = store\\n    <span class=hljs-keyword>this</span>.parentSub = parentSub\\n    <span class=hljs-keyword>this</span>.onStateChange = onStateChange\\n    <span class=hljs-keyword>this</span>.unsubscribe = <span class=hljs-literal>null</span>\\n    <span class=hljs-keyword>this</span>.listeners = nullListeners\\n  }\\n\\n  addNestedSub(listener) {\\n    <span class=hljs-keyword>this</span>.trySubscribe()\\n    <span class=hljs-keyword>return</span> <span class=hljs-keyword>this</span>.listeners.subscribe(listener)\\n  }\\n\\n  notifyNestedSubs() {\\n    <span class=hljs-keyword>this</span>.listeners.notify()\\n  }\\n\\n  isSubscribed() {\\n    <span class=hljs-keyword>return</span> <span class=hljs-built_in>Boolean</span>(<span class=hljs-keyword>this</span>.unsubscribe)\\n  }\\n\\n  trySubscribe() {\\n    <span class=hljs-keyword>if</span> (!<span class=hljs-keyword>this</span>.unsubscribe) {\\n      <span class=hljs-keyword>this</span>.unsubscribe = <span class=hljs-keyword>this</span>.parentSub\\n        ? <span class=hljs-keyword>this</span>.parentSub.addNestedSub(<span class=hljs-keyword>this</span>.onStateChange)\\n        : <span class=hljs-keyword>this</span>.store.subscribe(<span class=hljs-keyword>this</span>.onStateChange)\\n\\n      <span class=hljs-keyword>this</span>.listeners = createListenerCollection()\\n    }\\n  }\\n\\n  tryUnsubscribe() {\\n    <span class=hljs-keyword>if</span> (<span class=hljs-keyword>this</span>.unsubscribe) {\\n      <span class=hljs-keyword>this</span>.unsubscribe()\\n      <span class=hljs-keyword>this</span>.unsubscribe = <span class=hljs-literal>null</span>\\n      <span class=hljs-keyword>this</span>.listeners.clear()\\n      <span class=hljs-keyword>this</span>.listeners = nullListeners\\n    }\\n  }\\n}</code></pre> </div>\";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/react/redux/react-redux%E4%BB%8B%E7%BB%8D.md?")},285:function(module,exports){eval('// Module\nvar code = "<div class=note-title><p>React.createContext新的上下文</p> <p>React.createContext新的上下文</p> </div><div class=note-content><h3>API</h3> <ul> <li>React.createContext</li> <li>Context.Provider</li> <li>Class.contextType</li> <li>Context.Consumer</li> </ul> <pre><code class=\\"hljs jsx\\"><span class=hljs-keyword>const</span> ThemeContext = React.createContext({ <span class=hljs-attr>themes</span>: <span class=hljs-string>\'#fff\'</span> });\\n\\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>ThemeButton</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{\\n    <span class=hljs-keyword>static</span> contextType = ThemeContext;\\n\\n    render() {\\n        <span class=hljs-keyword>const</span> theme = <span class=hljs-keyword>this</span>.context.themes\\n        <span class=hljs-keyword>return</span> <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>onClick</span>=<span class=hljs-string>{this.props.toogleClick}</span>&gt;</span>{theme}<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span></span>\\n    }\\n}\\n\\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>ThemeBack</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{\\n    render() {\\n        <span class=hljs-keyword>return</span> (\\n            <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>ThemeContext.Consumer</span>&gt;</span>\\n                {(value) =&gt; {\\n                    return <span class=hljs-tag>&lt;<span class=hljs-name>div</span>&gt;</span>{value.themes}<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span>\\n                }}\\n            <span class=hljs-tag>&lt;/<span class=hljs-name>ThemeContext.Consumer</span>&gt;</span></span>\\n        )\\n    }\\n}\\n\\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>ToolButton</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{\\n    <span class=hljs-keyword>constructor</span>(props) {\\n        <span class=hljs-keyword>super</span>(props);\\n        <span class=hljs-keyword>this</span>.state = {\\n            <span class=hljs-attr>themes</span>: <span class=hljs-string>\\"#ccc\\"</span>\\n        } \\n    }\\n\\n    tooggleClick = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> {\\n        <span class=hljs-keyword>this</span>.setState({\\n            <span class=hljs-attr>themes</span>: <span class=hljs-string>\\"#000\\"</span>\\n        })    \\n    }\\n\\n    render() {\\n        <span class=hljs-keyword>return</span> (\\n            <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>ThemeContext.Provider</span> <span class=hljs-attr>value</span>=<span class=hljs-string>{this.state.themes}</span>&gt;</span>\\n                <span class=hljs-tag>&lt;<span class=hljs-name>ThemeButton</span> <span class=hljs-attr>onClick</span>=<span class=hljs-string>{this.tooggleClick}/</span>&gt;</span>\\n                <span class=hljs-tag>&lt;<span class=hljs-name>ThemeBack</span> /&gt;</span>\\n            <span class=hljs-tag>&lt;/<span class=hljs-name>ThemeContext.Provider</span>&gt;</span></span>\\n        )\\n    }\\n}</code></pre> <p><a href=https://react.jokcy.me/book/flow/render-root.html>https://react.jokcy.me/book/flow/render-root.html</a></p> </div>";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/react/basic_usage/context%E7%94%A8%E6%B3%95.md?')},286:function(module,exports){eval('// Module\nvar code = "<div class=note-title><p>hooks基础用法</p> <p>hooks的出现使得函数式组件得以有自己的状态(useState)，更为高级的是通过useEffect我们可以模拟class组件的生命周期，使得函数式组件可以基本代替class组件</p> </div><div class=note-content><p>Hooks 用于函数式组件，为函数式组件提供了类似于 class 组件的 state 状态功能；</p> <p>1、useState Function，定义 state 状态，可接受一个初始值，并返回长度为 2 的数组，</p> <pre><code class=\\"hljs js\\"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Demo</span>(<span class=hljs-params></span>) </span>{\\n  <span class=hljs-keyword>const</span> [count, setCount] = useState(<span class=hljs-number>0</span>);\\n  <span class=hljs-keyword>return</span> <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>onClick</span>=<span class=hljs-string>{()</span> =&gt;</span> setCount(count + 1)}&gt;{count}<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span></span>;\\n}</code></pre> <p>2、useEffect</p> <ul> <li>Function：类似于 class 组件生命周期功能，功能作用上类似于 componentDidMount、componentDidUpdate、componentWillUnmout 的组合</li> <li>useEffect 接受一个函数（componentDidMount 与 componentDidUpdate 的组合）作为参数，该函数可再次返回一个函数，用作清理 effect（类似于 componentWillUnmout，只不过不同的是该函数会在每次状态变化时被调用）</li> <li>useEffcet 接受一个数组作为第二个参数，该数组中放入特定的 state 值，React 会比较当前 state 与上一份 state 是否相等，从而决定调用传入的函数（使用了多个 useState、useEffcet 时，传入对应值，从而避免不必要的调用，提高性能）</li> </ul> <pre><code class=\\"hljs js\\"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Demo2</span>(<span class=hljs-params></span>) </span>{\\n  <span class=hljs-keyword>const</span> [count, setCount] = useState(<span class=hljs-number>0</span>);\\n  <span class=hljs-keyword>const</span> [demo, setDemo] = useState({ <span class=hljs-attr>count</span>: <span class=hljs-number>1</span> });\\n\\n  useEffect(<span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> {\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\\"effect:\\"</span>, count);\\n\\n    <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> {\\n      <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\\"clear effect\\"</span>);\\n    };\\n  });\\n\\n  useEffect(<span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> {\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\\"effect:\\"</span>, demo);\\n  }, [demo]);\\n\\n  useEffect(<span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> {\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\\"effect:\\"</span>, demo);\\n  }, [demo.count]);\\n\\n  useEffect(<span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> {\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\\"effect:\\"</span>, demo);\\n  }, []);\\n  <span class=hljs-keyword>return</span> <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>onClick</span>=<span class=hljs-string>{()</span> =&gt;</span> setCount(count + 1)}&gt;{count}<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span></span>;\\n}</code></pre> <blockquote> <p>值得注意的是每次函数组件被重新 render 时，useEffect 都会接受一个全新的函数，这个是 react 有意为之 不要在循环，条件或嵌套函数中调用 Hook。 相反，总是在 React 函数的顶层使用 Hooks，从而保证 useEffect 的调用顺序 useEffcet 的第二个参数传入一个空数组时，清理 effect 的函数此时功能与 componentWillUnmout 一致，只有在函数卸载时才会调用</p> </blockquote> <p>3、自定义 Hooks</p> <pre><code class=\\"hljs js\\">import React, { useState, useEffect } from \\"react\\";\\n\\nfunction EmitterCenter() {\\n  let effects = null;\\n\\n  const bindEffects = (unqueId, func) =&gt; {\\n    console.log(\\"bindEffects is Called\\");\\n    if (!effects) {\\n      effects = { [unqueId]: func };\\n    } else {\\n      if (effects[unqueId]) return;\\n      effects[unqueId] = func;\\n    }\\n  };\\n\\n  const callEffects = unqueId =&gt; {\\n    console.log(\\"callEffects is Called\\");\\n    const func = effects &amp;&amp; effects[unqueId];\\n    if (typeof func === \\"function\\") {\\n      func();\\n    }\\n  };\\n\\n  const unBindEffects = unqueId =&gt; {\\n    console.log(\\"unBindEffects is Called\\");\\n    if (!effects) return;\\n    delete effects[unqueId];\\n  };\\n  return {\\n    callEffects,\\n    bindEffects,\\n    unBindEffects\\n  };\\n}\\n\\nconst emitterCenter = new EmitterCenter();\\n\\nfunction useHooksCenter(type) {\\n  const [stateDemo, setStateDemo] = useState({\\n    demo: 2\\n  });\\n\\n  function handleAdd() {\\n    const middle = stateDemo.demo + 1;\\n    setStateDemo({ demo: middle });\\n  }\\n\\n  function handleSub() {\\n    const middle = stateDemo.demo - 1;\\n    setStateDemo({ demo: middle });\\n  }\\n\\n  useEffect(() =&gt; {\\n    let func = () =&gt; {};\\n\\n    if (type === \\"add\\") {\\n      func = handleAdd;\\n    } else if (type === \\"sub\\") {\\n      func = handleSub;\\n    }\\n\\n    emitterCenter.bindEffects(type, func);\\n    return () =&gt; {\\n      emitterCenter.unBindEffects(type);\\n    };\\n  }, [stateDemo]);\\n\\n  return stateDemo;\\n}\\n\\nfunction DemoTool() {\\n  const stateDemo = useHooksCenter(\\"sub\\");\\n\\n  return (\\n    &lt;div onClick={() =&gt; emitterCenter.callEffects(\\"sub\\")}&gt;{stateDemo.demo}&lt;/div&gt;\\n  );\\n}\\n\\nexport default function DemoHooks() {\\n  const [counts, setCounts] = useState(0);\\n  const [demoCount, setDemoCount] = useState({ demo: 1 });\\n  const stateDemo = useHooksCenter(\\"add\\");\\n\\n  useEffect(() =&gt; {\\n    console.log(\\"click:\\", counts);\\n  });\\n  useEffect(() =&gt; {\\n    console.log(\\"second effect\\", demoCount.demo);\\n  }, [demoCount]);\\n\\n  return [\\n    &lt;div\\n      key=\\"one\\"\\n      onClick={() =&gt; {\\n        setCounts(counts + 1);\\n      }}\\n    &gt;\\n      {counts}\\n      &lt;div onClick={() =&gt; emitterCenter.callEffects(\\"add\\")}&gt;\\n        {stateDemo.demo}\\n      &lt;/div&gt;\\n    &lt;/div&gt;,\\n    &lt;DemoTool key=\\"two\\" /&gt;,\\n    &lt;div key=\\"three\\" onClick={() =&gt; setDemoCount({ demo: demoCount.demo + 1 })}&gt;\\n      {demoCount.demo}\\n    &lt;/div&gt;\\n  ];\\n}</code></pre> <blockquote> <p>注意：自定义 Hooks 时，函数需以 use 开头，react 内部根据此规则来检测是否违反 Hooks 的规则</p> </blockquote> </div>";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/react/basic_usage/hooks%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95.md?')},287:function(module,exports){eval("// Module\nvar code = \"<div class=note-title><p>React.lazy与Suspense</p> <p>React.lazy与Suspense</p> </div><div class=note-content><p>一、代码分割 使用API：</p> <ul> <li>React.lazy 动态引入组件</li> <li>Suspense 组件动态加载过程可使用Suspense展示loading效果</li> </ul> <pre><code class=\\\"hljs jsx\\\"> <span class=hljs-keyword>const</span> Something = React.lazy(<span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> <span class=hljs-keyword>import</span>(<span class=hljs-string>'./Something'</span>));\\n <span class=hljs-keyword>const</span> AnotherThing = React.lazy(<span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> <span class=hljs-keyword>import</span>(<span class=hljs-string>'./AnotherThing'</span>));\\n\\n <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>SusComponent</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>return</span> (\\n        <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span>&gt;</span>\\n            <span class=hljs-tag>&lt;<span class=hljs-name>Suspense</span> <span class=hljs-attr>fallback</span>=<span class=hljs-string>{</span>&lt;<span class=hljs-attr>div</span>&gt;</span>Loading...<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span>}&gt;\\n                <span class=hljs-tag>&lt;<span class=hljs-name>Something</span> /&gt;</span>\\n                <span class=hljs-tag>&lt;<span class=hljs-name>AnotherThing</span> /&gt;</span>\\n            <span class=hljs-tag>&lt;/<span class=hljs-name>Suspense</span>&gt;</span>\\n        <span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span></span> \\n    )\\n }\\n\\n\\n<span class=hljs-keyword>import</span> { BrowserRouter <span class=hljs-keyword>as</span> Router, Route, Switch } <span class=hljs-keyword>from</span> <span class=hljs-string>'react-router-dom'</span>;\\n<span class=hljs-keyword>import</span> React, { Suspense, lazy } <span class=hljs-keyword>from</span> <span class=hljs-string>'react'</span>;\\n\\n<span class=hljs-keyword>const</span> Home = lazy(<span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> <span class=hljs-keyword>import</span>(<span class=hljs-string>'./routes/Home'</span>));\\n<span class=hljs-keyword>const</span> About = lazy(<span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> <span class=hljs-keyword>import</span>(<span class=hljs-string>'./routes/About'</span>));\\n\\n<span class=hljs-keyword>const</span> App = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> (\\n  <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>Router</span>&gt;</span>\\n    <span class=hljs-tag>&lt;<span class=hljs-name>Suspense</span> <span class=hljs-attr>fallback</span>=<span class=hljs-string>{</span>&lt;<span class=hljs-attr>div</span>&gt;</span>Loading...<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span>}&gt;\\n      <span class=hljs-tag>&lt;<span class=hljs-name>Switch</span>&gt;</span>\\n        <span class=hljs-tag>&lt;<span class=hljs-name>Route</span> <span class=hljs-attr>exact</span> <span class=hljs-attr>path</span>=<span class=hljs-string>\\\"/\\\"</span> <span class=hljs-attr>component</span>=<span class=hljs-string>{Home}/</span>&gt;</span>\\n        <span class=hljs-tag>&lt;<span class=hljs-name>Route</span> <span class=hljs-attr>path</span>=<span class=hljs-string>\\\"/about\\\"</span> <span class=hljs-attr>component</span>=<span class=hljs-string>{About}/</span>&gt;</span>\\n      <span class=hljs-tag>&lt;/<span class=hljs-name>Switch</span>&gt;</span>\\n    <span class=hljs-tag>&lt;/<span class=hljs-name>Suspense</span>&gt;</span>\\n  <span class=hljs-tag>&lt;/<span class=hljs-name>Router</span>&gt;</span></span>\\n);</code></pre> <p>二、Context</p> <ul> <li>React.createContext</li> <li>Context.Provider</li> <li>Class.contextType</li> <li>Context.Consumer</li> </ul> <pre><code class=\\\"hljs jsx\\\"><span class=hljs-keyword>const</span> ThemeContext = React.createContext({ <span class=hljs-attr>themes</span>: <span class=hljs-string>'#fff'</span> });\\n\\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>ThemeButton</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{\\n    <span class=hljs-keyword>static</span> contextType = ThemeContext;\\n\\n    render() {\\n        <span class=hljs-keyword>const</span> theme = <span class=hljs-keyword>this</span>.context.themes\\n        <span class=hljs-keyword>return</span> <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>div</span> <span class=hljs-attr>onClick</span>=<span class=hljs-string>{this.props.toogleClick}</span>&gt;</span>{theme}<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span></span>\\n    }\\n}\\n\\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>ThemeBack</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{\\n    render() {\\n        <span class=hljs-keyword>return</span> (\\n            <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>ThemeContext.Consumer</span>&gt;</span>\\n                {(value) =&gt; {\\n                    return <span class=hljs-tag>&lt;<span class=hljs-name>div</span>&gt;</span>{value.themes}<span class=hljs-tag>&lt;/<span class=hljs-name>div</span>&gt;</span>\\n                }}\\n            <span class=hljs-tag>&lt;/<span class=hljs-name>ThemeContext.Consumer</span>&gt;</span></span>\\n        )\\n    }\\n}\\n\\n<span class=hljs-class><span class=hljs-keyword>class</span> <span class=hljs-title>ToolButton</span> <span class=hljs-keyword>extends</span> <span class=hljs-title>React</span>.<span class=hljs-title>Component</span> </span>{\\n    <span class=hljs-keyword>constructor</span>(props) {\\n        <span class=hljs-keyword>super</span>(props);\\n        <span class=hljs-keyword>this</span>.state = {\\n            <span class=hljs-attr>themes</span>: <span class=hljs-string>\\\"#ccc\\\"</span>\\n        } \\n    }\\n\\n    tooggleClick = <span class=hljs-function><span class=hljs-params>()</span> =&gt;</span> {\\n        <span class=hljs-keyword>this</span>.setState({\\n            <span class=hljs-attr>themes</span>: <span class=hljs-string>\\\"#000\\\"</span>\\n        })    \\n    }\\n\\n    render() {\\n        <span class=hljs-keyword>return</span> (\\n            <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>ThemeContext.Provider</span> <span class=hljs-attr>value</span>=<span class=hljs-string>{this.state.themes}</span>&gt;</span>\\n                <span class=hljs-tag>&lt;<span class=hljs-name>ThemeButton</span> <span class=hljs-attr>onClick</span>=<span class=hljs-string>{this.tooggleClick}/</span>&gt;</span>\\n                <span class=hljs-tag>&lt;<span class=hljs-name>ThemeBack</span> /&gt;</span>\\n            <span class=hljs-tag>&lt;/<span class=hljs-name>ThemeContext.Provider</span>&gt;</span></span>\\n        )\\n    }\\n}</code></pre> <p><a href=https://react.jokcy.me/book/flow/render-root.html>https://react.jokcy.me/book/flow/render-root.html</a></p> </div>\";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/react/basic_usage/lazy%E4%B8%8Esuspend.md?")},288:function(module,exports){eval("// Module\nvar code = \"<div class=note-title><p>React源码分析之ReactBaseClasses</p> <p>ReactBaseClasses中定义了Component与PureComponent两个基类，以及基类中的基本api，包括props、context、refs、updater、isReactComponent、setState、forceUpdate。要注意Component与PureComponent仅仅是使用ES6语法定义的模版，在项目编译时，使用这两个基类创建的组件最终还是会被转变成React对象形式。</p> </div><div class=note-content> <h3>源码部分</h3> <pre><code class=\\\"hljs javascript\\\"><span class=hljs-comment>/**\\n * Copyright (c) 2013-present, Facebook, Inc.\\n *\\n * This source code is licensed under the MIT license found in the\\n * LICENSE file in the root directory of this source tree.\\n */</span>\\n\\n<span class=hljs-keyword>import</span> invariant <span class=hljs-keyword>from</span> <span class=hljs-string>'shared/invariant'</span>;\\n<span class=hljs-keyword>import</span> lowPriorityWarning <span class=hljs-keyword>from</span> <span class=hljs-string>'shared/lowPriorityWarning'</span>;\\n\\n<span class=hljs-keyword>import</span> ReactNoopUpdateQueue <span class=hljs-keyword>from</span> <span class=hljs-string>'./ReactNoopUpdateQueue'</span>;\\n\\n<span class=hljs-keyword>const</span> emptyObject = {};\\n<span class=hljs-keyword>if</span> (__DEV__) {\\n  <span class=hljs-built_in>Object</span>.freeze(emptyObject);\\n}\\n\\n<span class=hljs-comment>/**\\n * Base class helpers for the updating state of a component.\\n */</span>\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Component</span>(<span class=hljs-params>props, context, updater</span>) </span>{\\n  <span class=hljs-keyword>this</span>.props = props;\\n  <span class=hljs-keyword>this</span>.context = context;\\n  <span class=hljs-comment>// If a component has string refs, we will assign a different object later.</span>\\n  <span class=hljs-keyword>this</span>.refs = emptyObject;\\n  <span class=hljs-comment>// We initialize the default updater but the real one gets injected by the</span>\\n  <span class=hljs-comment>// renderer.</span>\\n  <span class=hljs-keyword>this</span>.updater = updater || ReactNoopUpdateQueue;\\n}\\n\\nComponent.prototype.isReactComponent = {};\\n\\n<span class=hljs-comment>/**\\n * Sets a subset of the state. Always use this to mutate\\n * state. You should treat `this.state` as immutable.\\n *\\n * There is no guarantee that `this.state` will be immediately updated, so\\n * accessing `this.state` after calling this method may return the old value.\\n *\\n * There is no guarantee that calls to `setState` will run synchronously,\\n * as they may eventually be batched together.  You can provide an optional\\n * callback that will be executed when the call to setState is actually\\n * completed.\\n *\\n * When a function is provided to setState, it will be called at some point in\\n * the future (not synchronously). It will be called with the up to date\\n * component arguments (state, props, context). These values can be different\\n * from this.* because your function may be called after receiveProps but before\\n * shouldComponentUpdate, and this new state, props, and context will not yet be\\n * assigned to this.\\n *\\n * @param {object|function} partialState Next partial state or function to\\n *        produce next partial state to be merged with current state.\\n * @param {?function} callback Called after state is updated.\\n * @final\\n * @protected\\n */</span>\\nComponent.prototype.setState = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>partialState, callback</span>) </span>{\\n  invariant(\\n    <span class=hljs-keyword>typeof</span> partialState === <span class=hljs-string>'object'</span> ||\\n      <span class=hljs-keyword>typeof</span> partialState === <span class=hljs-string>'function'</span> ||\\n      partialState == <span class=hljs-literal>null</span>,\\n    <span class=hljs-string>'setState(...): takes an object of state variables to update or a '</span> +\\n      <span class=hljs-string>'function which returns an object of state variables.'</span>,\\n  );\\n  <span class=hljs-keyword>this</span>.updater.enqueueSetState(<span class=hljs-keyword>this</span>, partialState, callback, <span class=hljs-string>'setState'</span>);\\n};\\n\\n<span class=hljs-comment>/**\\n * Forces an update. This should only be invoked when it is known with\\n * certainty that we are **not** in a DOM transaction.\\n *\\n * You may want to call this when you know that some deeper aspect of the\\n * component's state has changed but `setState` was not called.\\n *\\n * This will not invoke `shouldComponentUpdate`, but it will invoke\\n * `componentWillUpdate` and `componentDidUpdate`.\\n *\\n * @param {?function} callback Called after update is complete.\\n * @final\\n * @protected\\n */</span>\\nComponent.prototype.forceUpdate = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>callback</span>) </span>{\\n  <span class=hljs-keyword>this</span>.updater.enqueueForceUpdate(<span class=hljs-keyword>this</span>, callback, <span class=hljs-string>'forceUpdate'</span>);\\n};\\n\\n<span class=hljs-comment>/**\\n * Deprecated APIs. These APIs used to exist on classic React classes but since\\n * we would like to deprecate them, we're not going to move them over to this\\n * modern base class. Instead, we define a getter that warns if it's accessed.\\n */</span>\\n<span class=hljs-keyword>if</span> (__DEV__) {\\n  <span class=hljs-keyword>const</span> deprecatedAPIs = {\\n    <span class=hljs-attr>isMounted</span>: [\\n      <span class=hljs-string>'isMounted'</span>,\\n      <span class=hljs-string>'Instead, make sure to clean up subscriptions and pending requests in '</span> +\\n        <span class=hljs-string>'componentWillUnmount to prevent memory leaks.'</span>,\\n    ],\\n    <span class=hljs-attr>replaceState</span>: [\\n      <span class=hljs-string>'replaceState'</span>,\\n      <span class=hljs-string>'Refactor your code to use setState instead (see '</span> +\\n        <span class=hljs-string>'https://github.com/facebook/react/issues/3236).'</span>,\\n    ],\\n  };\\n  <span class=hljs-keyword>const</span> defineDeprecationWarning = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>methodName, info</span>) </span>{\\n    <span class=hljs-built_in>Object</span>.defineProperty(Component.prototype, methodName, {\\n      <span class=hljs-attr>get</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n        lowPriorityWarning(\\n          <span class=hljs-literal>false</span>,\\n          <span class=hljs-string>'%s(...) is deprecated in plain JavaScript React classes. %s'</span>,\\n          info[<span class=hljs-number>0</span>],\\n          info[<span class=hljs-number>1</span>],\\n        );\\n        <span class=hljs-keyword>return</span> <span class=hljs-literal>undefined</span>;\\n      },\\n    });\\n  };\\n  <span class=hljs-keyword>for</span> (<span class=hljs-keyword>const</span> fnName <span class=hljs-keyword>in</span> deprecatedAPIs) {\\n    <span class=hljs-keyword>if</span> (deprecatedAPIs.hasOwnProperty(fnName)) {\\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\\n    }\\n  }\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>ComponentDummy</span>(<span class=hljs-params></span>) </span>{}\\nComponentDummy.prototype = Component.prototype;\\n\\n<span class=hljs-comment>/**\\n * Convenience component with default shallow equality check for sCU.\\n */</span>\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>PureComponent</span>(<span class=hljs-params>props, context, updater</span>) </span>{\\n  <span class=hljs-keyword>this</span>.props = props;\\n  <span class=hljs-keyword>this</span>.context = context;\\n  <span class=hljs-comment>// If a component has string refs, we will assign a different object later.</span>\\n  <span class=hljs-keyword>this</span>.refs = emptyObject;\\n  <span class=hljs-keyword>this</span>.updater = updater || ReactNoopUpdateQueue;\\n}\\n\\n<span class=hljs-keyword>const</span> pureComponentPrototype = (PureComponent.prototype = <span class=hljs-keyword>new</span> ComponentDummy());\\npureComponentPrototype.constructor = PureComponent;\\n<span class=hljs-comment>// Avoid an extra prototype jump for these methods.</span>\\n<span class=hljs-built_in>Object</span>.assign(pureComponentPrototype, Component.prototype);\\npureComponentPrototype.isPureReactComponent = <span class=hljs-literal>true</span>;\\n\\n<span class=hljs-keyword>export</span> {Component, PureComponent};</code></pre> <p>&emsp;&emsp;本部分比较简单，只是使用<code>ES6</code>语法定义了两个基类，类中定义了组件所拥有的基本属性。 &emsp;&emsp;<code>PureComponent</code>与<code>Component</code>定义基本一致，并且<code>PureComponent</code>通过原型继承了<code>Component</code>，不同点是<code>PureComponent</code>在原型上也添加了一个标记<code>isPureReactComponent</code>，这个标记会在组件<code>render</code>过程中组件类型，从而确定是深比较，还是浅比较。 &emsp;&emsp;我们都知道，使用React时，除了引入<code>React</code>基类外，还会引入<code>ReactDOM</code>。开发中时，两个类各司其职，<code>React</code>定义<code>React对象</code>，而<code>ReactDOM</code>是则是将<code>React对象</code>所形成的虚拟DOM树渲染成真正的DOM在浏览器上展示。而在组件的渲染生命周期内，会通过组件类型判断深或浅比较<code>state</code>或<code>props</code>，来决定组件是否要进行重新<code>render</code>。</p> </div>\";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/react/source_code/React%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BReactBaseClasses.md?")},289:function(module,exports){eval("// Module\nvar code = \"<div class=note-title><p>面向切面编程</p> <p>面向切面编程</p> </div><div class=note-content><h4>js之面向切面编程</h4> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>const</span> extendsObjs: any = <span class=hljs-built_in>Function</span>.prototype;\\n\\nextendsObjs.before = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>Func: Function</span>) </span>{\\n  <span class=hljs-keyword>const</span> _self = <span class=hljs-keyword>this</span>;\\n\\n  <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    Func.apply(<span class=hljs-keyword>this</span>, <span class=hljs-built_in>arguments</span>);\\n    <span class=hljs-keyword>return</span> _self.apply(<span class=hljs-keyword>this</span>, <span class=hljs-built_in>arguments</span>);\\n  }\\n}\\n\\nextendsObjs.after = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>Func: Function</span>) </span>{\\n  <span class=hljs-keyword>const</span> _self = <span class=hljs-keyword>this</span>;\\n\\n  <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>const</span> yet = _self.apply(<span class=hljs-keyword>this</span>, <span class=hljs-built_in>arguments</span>)\\n\\n    Func.apply(<span class=hljs-keyword>this</span>, <span class=hljs-built_in>arguments</span>);\\n\\n    <span class=hljs-keyword>return</span> yet;\\n  }\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>Aop</span>(<span class=hljs-params></span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'this is aop test'</span>);\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>BeforeAop</span>(<span class=hljs-params></span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'this is before aop function'</span>);\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>AfterAop</span>(<span class=hljs-params></span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'1 this is after aop function'</span>);\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>AfterAop2</span>(<span class=hljs-params></span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'2 this is after aop function'</span>);\\n}\\n\\n(Aop <span class=hljs-keyword>as</span> any).before(BeforeAop).before(BeforeAop)();\\n\\n(Aop <span class=hljs-keyword>as</span> any).after(AfterAop).after(AfterAop2);</code></pre> </div>\";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/javascript/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B.md?")},290:function(module,exports){eval("// Module\nvar code = \"<div class=note-title><p>设计模式</p> <p>设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案</p> </div><div class=note-content><h3>函数柯里化</h3> <p>&emsp;&emsp;通俗来讲函数柯里化是将多参函数转换为单参函数，并且能返回一个函数，该函数能够处理原本函数剩余的参数。</p> <ul> <li>基本实现一</li> </ul> <pre><code class=\\\"hljs javascript\\\"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>currying</span>(<span class=hljs-params>fn</span>) </span>{\\n    <span class=hljs-keyword>var</span> slice = <span class=hljs-built_in>Array</span>.prototype.slice;\\n    <span class=hljs-keyword>var</span> _args = slice.call(<span class=hljs-built_in>arguments</span>, <span class=hljs-number>1</span>);\\n    <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n        <span class=hljs-keyword>var</span> _argsBack = slice.call(<span class=hljs-built_in>arguments</span>);\\n        <span class=hljs-keyword>return</span> fn.apply(<span class=hljs-literal>null</span>, _args.concat(_argsBack));\\n    }\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>map</span>(<span class=hljs-params>func, arr</span>) </span>{\\n    <span class=hljs-keyword>return</span> arr.map(func);\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>square</span>(<span class=hljs-params>i</span>) </span>{\\n    <span class=hljs-keyword>return</span> i * i;\\n}\\n\\n<span class=hljs-keyword>var</span> curA = currying(map, square);\\n<span class=hljs-built_in>console</span>.log(curA([<span class=hljs-number>1</span>, <span class=hljs-number>2</span>, <span class=hljs-number>3</span>, <span class=hljs-number>4</span>]));</code></pre> <ul> <li>基本实现二</li> </ul> <pre><code class=\\\"hljs javascript\\\"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>currying</span>(<span class=hljs-params>fn</span>) </span>{\\n    <span class=hljs-keyword>var</span> arr = [];\\n    <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n        <span class=hljs-keyword>if</span> (<span class=hljs-built_in>arguments</span>.length === <span class=hljs-number>0</span>) {\\n            <span class=hljs-keyword>return</span> fn.apply(<span class=hljs-keyword>this</span>, arr);\\n        }\\n        <span class=hljs-built_in>Array</span>.prototype.push.apply(arr, [].slice.call(<span class=hljs-built_in>arguments</span>));\\n        <span class=hljs-keyword>return</span> <span class=hljs-built_in>arguments</span>.callee;\\n    }\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>sumFn</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>var</span> sum = <span class=hljs-number>0</span>;\\n    <span class=hljs-built_in>Array</span>.prototype.forEach.call(<span class=hljs-built_in>arguments</span>, item =&gt; {\\n        sum += item;\\n    });\\n    <span class=hljs-keyword>return</span> sum;\\n}\\n\\n<span class=hljs-keyword>var</span> sunCurry = currying(sumFn);\\n<span class=hljs-built_in>console</span>.log(sunCurry(<span class=hljs-number>1</span>)(<span class=hljs-number>2</span>)(<span class=hljs-number>4</span>)());</code></pre> <h3>单例模式</h3> <p>单例模式要求一个类有且仅有一个实例，即当方法内部的类被实例化后，之后该方法被使用时，内部的类不会再进行第二次实例化;</p> <p>js实现</p> <pre><code class=\\\"hljs javascript\\\"><span class=hljs-keyword>const</span> singleton = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>let</span> caseSing;\\n    <span class=hljs-keyword>const</span> init = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n        <span class=hljs-keyword>return</span> {\\n            <span class=hljs-attr>publicFn</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n                <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'this is a singleton'</span>);\\n            },\\n            <span class=hljs-attr>publicPt</span>: <span class=hljs-string>'singleton'</span>\\n        }\\n    }\\n    <span class=hljs-keyword>return</span> {\\n        <span class=hljs-attr>getCase</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n            caseSing = caseSing ? caseSing : init();\\n            <span class=hljs-keyword>return</span> caseSing;\\n        }\\n    }\\n}\\n\\n<span class=hljs-comment>// 使用</span>\\nsingleton.getCase().publicFn();</code></pre> <h3>观察者模式</h3> <p>&emsp;&emsp;一系列对象的表现或行为依赖于某个对象，由该对象通知依赖对象的行为变化。</p> <pre><code class=\\\"hljs javascript\\\"><span class=hljs-keyword>var</span> ObserveList = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>this</span>.list = [];\\n}\\nObserveList.prototype = {\\n    <span class=hljs-attr>constructor</span>: ObserveList,\\n    <span class=hljs-attr>add</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>obj</span>) </span>{\\n        <span class=hljs-keyword>this</span>.list.push(obj);\\n    },\\n    <span class=hljs-attr>get</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>i</span>) </span>{\\n        <span class=hljs-keyword>if</span>(i &gt; <span class=hljs-number>-1</span> &amp;&amp; i &lt; <span class=hljs-keyword>this</span>.list.length) {\\n            <span class=hljs-keyword>return</span> <span class=hljs-keyword>this</span>.list[i];\\n        }\\n        <span class=hljs-keyword>return</span> <span class=hljs-literal>null</span>;\\n    },\\n    <span class=hljs-attr>remove</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>i</span>) </span>{\\n        <span class=hljs-keyword>if</span>(i &gt; <span class=hljs-number>-1</span> &amp;&amp; i &lt; <span class=hljs-keyword>this</span>.list.length) {\\n            <span class=hljs-keyword>this</span>.list.splice(i, <span class=hljs-number>1</span>);\\n        }\\n    }\\n}\\n\\n<span class=hljs-keyword>var</span> Subject = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>this</span>.observe = <span class=hljs-keyword>new</span> ObserveList();\\n}\\nSubject.prototype = {\\n    <span class=hljs-attr>constructor</span>: Subject,\\n    <span class=hljs-attr>addObserve</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>obj</span>) </span>{\\n        <span class=hljs-keyword>this</span>.observe.add(obj);\\n    },\\n    <span class=hljs-attr>removeObserve</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>i</span>) </span>{\\n        <span class=hljs-keyword>this</span>.observe.remove(i)\\n    },\\n    <span class=hljs-attr>notify</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>val</span>) </span>{\\n        <span class=hljs-keyword>for</span>(<span class=hljs-keyword>var</span> i=<span class=hljs-number>0</span>;i&lt;<span class=hljs-keyword>this</span>.observe.list.length;i++) {\\n            <span class=hljs-keyword>this</span>.observe.get(i).func(val);\\n        }\\n    }\\n}\\n\\n<span class=hljs-keyword>var</span> Observe = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>this</span>.func = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{}\\n};\\n\\n<span class=hljs-keyword>var</span> Extends = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>obj1, obj2</span>) </span>{\\n    <span class=hljs-keyword>for</span>(<span class=hljs-keyword>var</span> key <span class=hljs-keyword>in</span> obj2) {\\n        obj1[key]  = obj2[key];\\n    }\\n    <span class=hljs-keyword>return</span> obj1;\\n}\\n\\n<span class=hljs-keyword>var</span> sub = Extends({}, <span class=hljs-keyword>new</span> Subject());\\n\\n<span class=hljs-keyword>var</span> obs1 = Extends({}, <span class=hljs-keyword>new</span> Observe());\\nobs1.func = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>val</span>) </span>{\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'obs1'</span>, val);\\n}\\n<span class=hljs-keyword>var</span> obs2 = Extends({}, <span class=hljs-keyword>new</span> Observe());\\nobs2.func = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>val</span>) </span>{\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'obs2'</span>, val)\\n}\\n\\nsub.addObserve(obs1);\\nsub.addObserve(obs2);\\n\\nsub.notify(<span class=hljs-string>'12:57'</span>);</code></pre> <h3>订阅发布模式</h3> <p>&emsp;&emsp;订阅发布模式与观察者模式类似，主要区别是观察者模式目标与观察者之间是直接联系的，目标对象知道它自身有哪些观察者，而订阅发布模式比观察者模式多了个中间处理层，目标对象和观察者不直接联系，而是通过中间层完成订阅与发布。</p> <pre><code class=\\\"hljs javascript\\\"><span class=hljs-keyword>var</span> Intermediate = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>var</span> mediate = {};\\n    <span class=hljs-keyword>var</span> token = <span class=hljs-number>-1</span>;\\n    <span class=hljs-keyword>this</span>.subscribe = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>type, func, context</span>) </span>{\\n        <span class=hljs-keyword>if</span> (!mediate[type]) {\\n            mediate[type] = [];\\n        }\\n        token += <span class=hljs-number>1</span>; \\n        mediate[type].push({\\n          <span class=hljs-attr>context</span>: context || <span class=hljs-keyword>this</span>,\\n          token,\\n          func\\n        });\\n        <span class=hljs-keyword>return</span> token;\\n    }\\n    <span class=hljs-keyword>this</span>.publish = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>type</span>) </span>{\\n        <span class=hljs-keyword>var</span> args = <span class=hljs-built_in>Array</span>.prototype.splice.call(<span class=hljs-built_in>arguments</span>, <span class=hljs-number>1</span>)\\n        <span class=hljs-keyword>var</span> items = mediate[type];\\n        <span class=hljs-keyword>if</span> (items) {\\n            items.forEach(<span class=hljs-function><span class=hljs-params>item</span> =&gt;</span> {\\n                item.func.apply(item.context, args);\\n            });\\n        }\\n    }\\n    <span class=hljs-keyword>this</span>.remove = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>token</span>) </span>{\\n        <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> key <span class=hljs-keyword>in</span> mediate) {\\n            <span class=hljs-keyword>var</span> itemArr = mediate[key];\\n            <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i = <span class=hljs-number>0</span>; i &lt; itemArr.length; i++) {\\n                <span class=hljs-keyword>if</span> (itemArr[i].token === token) {\\n                    itemArr.splice(i, <span class=hljs-number>1</span>);\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n<span class=hljs-keyword>var</span> modal = <span class=hljs-keyword>new</span> Intermediate();\\n<span class=hljs-keyword>var</span> one0 = modal.subscribe(<span class=hljs-string>'one'</span>, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'one0 被触发'</span>, <span class=hljs-built_in>arguments</span>);\\n});\\n<span class=hljs-keyword>var</span> one1 = modal.subscribe(<span class=hljs-string>'one'</span>, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'one1 被触发'</span>, <span class=hljs-built_in>arguments</span>);\\n})\\n<span class=hljs-keyword>var</span> one1 = modal.subscribe(<span class=hljs-string>'two'</span>, <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'two 被触发'</span>, <span class=hljs-built_in>arguments</span>);\\n})\\nmodal.publish(<span class=hljs-string>'one'</span>, <span class=hljs-number>1</span>, <span class=hljs-number>2</span>);\\nmodal.publish(<span class=hljs-string>'two'</span>, <span class=hljs-number>1</span>, <span class=hljs-number>2</span>);\\nmodal.remove(one0);\\nmodal.publish(<span class=hljs-string>'one'</span>, <span class=hljs-number>1</span>, <span class=hljs-number>2</span>);</code></pre> <h3>Facade外观模式</h3> <p>&emsp;&emsp;Facade是对复杂性问题的一种封装，即将复杂性逻辑封装在内部，并提供简单的调用方式来供他人使用</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>var</span> <span class=hljs-built_in>module</span> = (<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-keyword>var</span> _private = {\\n        <span class=hljs-attr>i</span>: <span class=hljs-number>5</span>,\\n        <span class=hljs-attr>get</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n            <span class=hljs-built_in>console</span>.log(<span class=hljs-keyword>this</span>.i);\\n        },\\n        <span class=hljs-attr>set</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>val</span>) </span>{\\n            <span class=hljs-keyword>this</span>.i = val;\\n        },\\n        <span class=hljs-attr>run</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n            <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'running'</span>);\\n        },\\n        <span class=hljs-attr>jump</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n            <span class=hljs-built_in>console</span>.log(<span class=hljs-string>\\\"jumping\\\"</span>);\\n        }\\n    };\\n\\n    <span class=hljs-keyword>return</span> {\\n        <span class=hljs-attr>facade</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>args</span>) </span>{\\n            _private.set(args.val);\\n            _private.get();\\n\\n            <span class=hljs-keyword>if</span> (args.run) {\\n                _private.run();\\n            }\\n        }\\n    }\\n})()\\n\\n<span class=hljs-built_in>module</span>.facade({ <span class=hljs-attr>run</span>: <span class=hljs-literal>true</span>, <span class=hljs-attr>val</span>: <span class=hljs-number>10</span>});</code></pre> <p><a href=http://wiki.jikexueyuan.com/project/javascript-design-patterns/mediator-pattern.html>设计模式</a></p> </div>\";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/javascript/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md?")},291:function(module,exports){eval('// Module\nvar code = "<div class=note-title><p>继承</p> <p>所谓继承，就是把一些有共性的东西分类，然后提取公共属性，当定义子类时直接从父类中继承这些具有共性的方法或属性，ES6以前JS并没有提供原生继承方式，但是可以通过函数以及原型链的一些特性模拟出继承</p> </div><div class=note-content><h3>直接使用原型链</h3> <pre><code class=\\"hljs js\\"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>SuperType</span>(<span class=hljs-params></span>)</span>{\\n  <span class=hljs-keyword>this</span>.colors = [<span class=hljs-string>\\"red\\"</span>,<span class=hljs-string>\\"blue\\"</span>,<span class=hljs-string>\\"green\\"</span>];\\n}\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>SubType</span>(<span class=hljs-params></span>)</span>{}\\nSubType.prototype = <span class=hljs-keyword>new</span> SuperType();\\n\\n<span class=hljs-keyword>var</span> instance1 = <span class=hljs-keyword>new</span> SubType();\\ninstance1.colors.push(<span class=hljs-string>\\"black\\"</span>);\\nalert(instance1.colors); <span class=hljs-comment>//\\"red,blue,green,black\\"</span>\\n\\n<span class=hljs-keyword>var</span> instance2 = <span class=hljs-keyword>new</span> SubType();\\nalert(instance2.colors); <span class=hljs-comment>//\\"red,blue,green,black\\"</span></code></pre> <blockquote> <p>由上例可见，直接使用原型链，每个SuperType的实例都共享同样一份colors，一个对象实例改变其内容，其他对象实例中的colors内容同样改变，还有就是原型链无法向构造函数传递参数。</p> </blockquote> <h3>借用构造函数继承</h3> <ul> <li>通过函数的apply()或call()方法实现</li> </ul> <pre><code class=\\"hljs js\\"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>SuperType</span>(<span class=hljs-params></span>)</span>{\\n  <span class=hljs-keyword>this</span>.colors = [<span class=hljs-string>\\"red\\"</span>,<span class=hljs-string>\\"blue\\"</span>,<span class=hljs-string>\\"green\\"</span>];\\n}\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>SubType</span>(<span class=hljs-params></span>)</span>{\\n  SuperType.call(<span class=hljs-keyword>this</span>);\\n}\\n<span class=hljs-keyword>var</span> intance1 = <span class=hljs-keyword>new</span> SubType();\\nintance1.colors.push(<span class=hljs-string>\\"black\\"</span>);\\nalert(instance1.colors);  <span class=hljs-comment>//\\"red,blue,green,black\\"</span>\\n\\n<span class=hljs-keyword>var</span> intance2 = <span class=hljs-keyword>new</span> Subtype();\\nalert(instance2.colors);  <span class=hljs-comment>//\\"red,blue,green\\"</span></code></pre> <blockquote> <p>借用构造函数的缺点很大，由于使用call或者apply，子类只能访问父类函数内的属性或方法，而父类原型中所携带的方法和属性对子类是不可见的</p> </blockquote> <h3>组合继承</h3> <p> 组合继承结合了原型链和借用构造函数的两种继承方式，它使用原型链实现了对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承，这样即保证了父类原型上定义的方法和属性对子类可见，同时又保证了每个实例都有它自己的属性，互相之间不存在影响</p> <pre><code class=\\"hljs js\\">  <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>SuperType</span>(<span class=hljs-params>name</span>)</span>{\\n    <span class=hljs-keyword>this</span>.name = name;\\n    <span class=hljs-keyword>this</span>.colors = [<span class=hljs-string>\\"red\\"</span>,<span class=hljs-string>\\"blue\\"</span>,<span class=hljs-string>\\"green\\"</span>];\\n  }\\n  SuperType.prototype.sayName = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{\\n    alert(<span class=hljs-keyword>this</span>.name);\\n  }\\n\\n  <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>SubType</span>(<span class=hljs-params>name,age</span>)</span>{\\n    SuperType.call(<span class=hljs-keyword>this</span>,name);\\n    <span class=hljs-keyword>this</span>.age = age;\\n  }\\n  SubType.prototype = <span class=hljs-keyword>new</span> SuperType();\\n  SubType.prototype.sayAge = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>)</span>{\\n    alert(<span class=hljs-keyword>this</span>.age);\\n  }\\n  <span class=hljs-keyword>var</span> instance1 = <span class=hljs-keyword>new</span> SubType(<span class=hljs-string>\\"Nicholas\\"</span>,<span class=hljs-number>29</span>);\\n  instance1.colors.push(<span class=hljs-string>\\"black\\"</span>);\\n  alert(instance1.colors);  <span class=hljs-comment>//\\"red,blue,green,black\\"</span>\\n  instance1.sayName();  <span class=hljs-comment>//\\"Nicholas\\"</span>\\n  instance1.sayAge(); <span class=hljs-comment>//27</span>\\n\\n  <span class=hljs-keyword>var</span> instance2 = <span class=hljs-keyword>new</span> SubType(<span class=hljs-string>\\"Greg\\"</span>,<span class=hljs-number>27</span>);\\n  alert(instance2.colors);  <span class=hljs-comment>//\\"red,blue,green\\"</span>\\n  instance1.sayName();  <span class=hljs-comment>//\\"Greg\\"</span>\\n  instance2.sayAge(); <span class=hljs-comment>//27</span></code></pre> <blockquote> <p>本内容主要参考JavaScript高级教程继承部分，除此以上三种继承之外，还有寄生式继承、寄生组合式继承等，此处不再一一列举，详细请去阅读JavaScript高级教程</p> </blockquote> </div>";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/javascript/%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0.md?')},292:function(module,exports,__webpack_require__){eval("// Imports\nvar ___HTML_LOADER_GET_SOURCE_FROM_IMPORT___ = __webpack_require__(293);\nvar ___HTML_LOADER_IMPORT_0___ = __webpack_require__(294);\n// Module\nvar ___HTML_LOADER_REPLACER_0___ = ___HTML_LOADER_GET_SOURCE_FROM_IMPORT___(___HTML_LOADER_IMPORT_0___);\nvar code = \"<div class=note-title><p>尾调用与执行栈任务队列</p> <p>尾调用与执行栈任务队列</p> </div><div class=note-content><p><strong>一、尾调用</strong></p> <p>尾调用通俗讲是在函数的最后一步调用另一函数</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-meta>'use strict'</span>  <span class=hljs-comment>// 以下测试只在js严格模式下，且必须safari浏览器才生效</span>\\nfuntion originCall(n) {\\n    <span class=hljs-keyword>return</span> n;\\n}\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>callerCallA</span>(<span class=hljs-params>m</span>) </span>{\\n    <span class=hljs-keyword>const</span> c = originCall(m); <span class=hljs-comment>// 犹豫originCall执行结果赋值给c，所以函数执行上下文不会从执行栈中移除</span>\\n    <span class=hljs-keyword>return</span> c; <span class=hljs-comment>// 非尾调用，</span>\\n}\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>callerCall</span>(<span class=hljs-params>m</span>) </span>{\\n    <span class=hljs-keyword>return</span> m + originCall(m); <span class=hljs-comment>// 函数最后一句并非单纯调用另一函数，所以非尾调用</span>\\n}\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>recursionCall</span>(<span class=hljs-params>v</span>) </span>{\\n    <span class=hljs-keyword>return</span> originCall(v) <span class=hljs-comment>// 尾调用</span>\\n}</code></pre> <p>理解尾调用首先需要了解js执行栈与执行上下文相关知识</p> <ul> <li><p>执行上下文：每次当控制器转到ECMAScript可执行代码的时候，即会进入到一个执行上下文(EC)</p> </li> <li><p>执行栈：js代码进入执行后，会形成一个call stack(以下简写CS)，CS栈首先压入栈底的是global EC--&gt;全局执行上下文(内容包含变量对象、作用域链以及this)，global EC执行的过程中当遇到方法时，会产生该方法的执行上下文，然后方法执行上下文被压入栈，执行该方法，该方法执行过程中若遇到其它方法，重复以上过程……，当方法执行完毕，call stack会移除当前方法执行上下文，执行权交给放在栈顶的执行上下文……</p> </li> </ul> <p>​ <strong>尾调用</strong>就是利用执行栈对执行上下文push与pop做优化的，Call Stack会在函数执行完毕后将函数执行上下文移除栈顶(return或抛出异常都可以结束函数上下文，也就是函数执行结束)，所以尾调用就是在函数最后一步调用另一函数，原函数执行完毕被移除栈，并将return之后执行的函数压入栈中。</p> <p>​ 利用尾调用可以在递归时做一些优化，防止栈溢出。</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-meta>'use strict'</span>; <span class=hljs-comment>// 以下测试只在js严格模式下，且必须safari浏览器才生效</span>\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>recursion</span>(<span class=hljs-params>n</span>) </span>{\\n  <span class=hljs-keyword>if</span> (n === <span class=hljs-number>0</span>) {\\n    <span class=hljs-keyword>return</span> <span class=hljs-number>0</span>;\\n  }\\n  <span class=hljs-keyword>return</span> recursion(n - <span class=hljs-number>1</span>) + n;\\n}\\n\\n<span class=hljs-keyword>const</span> sum = recursion(<span class=hljs-number>100000</span>); <span class=hljs-comment>// 栈溢出</span>\\n<span class=hljs-built_in>console</span>.log(sum)\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>recursionTail</span>(<span class=hljs-params>n, sum</span>) </span>{\\n  <span class=hljs-keyword>if</span> (n === <span class=hljs-number>0</span>) {\\n    <span class=hljs-keyword>return</span> sum;\\n  }\\n  <span class=hljs-keyword>return</span> recursionTail(n - <span class=hljs-number>1</span>, n + sum);\\n}\\n\\n<span class=hljs-keyword>const</span> sumTail = recursionTail(<span class=hljs-number>100000</span>, <span class=hljs-number>0</span>); <span class=hljs-comment>// 运行正常</span>\\n<span class=hljs-built_in>console</span>.log(sumTail)</code></pre> <blockquote> <p>Note：ES6尾调用优化只在严格模式下开启，正常模式无效，且经过测试尾调用优化只在safari浏览器中实现了，其他浏览器暂未实现</p> <p>V8引擎官方团队对此官方解释：Proper tail calls have been implemented but not yet shipped given that a change to the feature is currently under discussion at TC39. (实际已实现，但未发布)</p> </blockquote> <p>当然，为了避免递归造成的call stack溢出，可以通过循环形式，避免递归调用，例如</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>recursionTail</span>(<span class=hljs-params>n, sum</span>) </span>{\\n  <span class=hljs-keyword>if</span> (n === <span class=hljs-number>0</span>) {\\n    <span class=hljs-keyword>return</span> sum;\\n  }\\n  <span class=hljs-comment>// 此处返回原函数模板，并将需要的参数传递进去，由于此处并无函数调用，所以return之后，call stack 会移除recursionTail的调用记录</span>\\n  <span class=hljs-keyword>return</span> recursionTail.bind(<span class=hljs-literal>null</span>, n - <span class=hljs-number>1</span>, n + sum);\\n}\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>trampoline</span>(<span class=hljs-params>func</span>) </span>{\\n  <span class=hljs-comment>// 这里利用循环调用recursionTail函数返回的函数模板，从而达到递归同样的功能</span>\\n  <span class=hljs-keyword>while</span> (func &amp;&amp; <span class=hljs-keyword>typeof</span> func === <span class=hljs-string>'function'</span>) {\\n    func = func()\\n  }\\n  <span class=hljs-keyword>return</span> func;\\n}\\n\\n<span class=hljs-keyword>const</span> test = trampoline(recursionTail(<span class=hljs-number>100000</span>, <span class=hljs-number>0</span>))</code></pre> <p>以及</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>hocTail</span>(<span class=hljs-params>func</span>) </span>{\\n  <span class=hljs-keyword>const</span> midlleArg = []; <span class=hljs-comment>// 此处是闭包中的一个中间量，用来记录每次结果，以便传入下一次循环总</span>\\n  <span class=hljs-keyword>let</span> value;\\n  <span class=hljs-keyword>let</span> active = <span class=hljs-literal>false</span>;\\n  <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    midlleArg.push(<span class=hljs-built_in>arguments</span>);\\n\\n    <span class=hljs-keyword>if</span> (!active) {\\n      active = <span class=hljs-literal>true</span>;\\n      <span class=hljs-keyword>while</span>(midlleArg.length) {\\n        value = func.apply(<span class=hljs-keyword>this</span>, midlleArg.shift()) <span class=hljs-comment>// 此处由于每次调用都会向中间量midlleArg塞入上一次的结果，所以while循环会持续进行，直到函数内部不在调用当前方法</span>\\n      }\\n      active = <span class=hljs-literal>false</span>;\\n      <span class=hljs-keyword>return</span> value;\\n    }\\n  }\\n}\\n\\n<span class=hljs-keyword>const</span> sumTail = hocTail(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>n, sum</span>) </span>{\\n  <span class=hljs-keyword>if</span> (n === <span class=hljs-number>0</span>) {\\n    <span class=hljs-keyword>return</span> sum;\\n  }\\n  <span class=hljs-keyword>return</span> sumTail(n - <span class=hljs-number>1</span>, n + sum);\\n})\\n\\n<span class=hljs-keyword>const</span> test = sumTail(<span class=hljs-number>100000</span>, <span class=hljs-number>0</span>);\\n\\n<span class=hljs-built_in>console</span>.log(test)</code></pre> <p>通俗的来说，尾递归的优化就是避免递归时返回的值为函数调用，比如上二例，第一例是返回bind形成的函数模板，第二例是返回的undefined，这样函数执行完毕，执行栈自然会将函数调用记录从执行栈中移除</p> <p><strong>二、event loops与task quene</strong></p> <p>js是单线程语言，代码执行分为同步和异步任务，当浏览器加载主线程开始执行js代码时，会开辟一块call stack执任务，在执行任务时遇到异步模块，会将异步模块压入任务队列(先进先出)，待主线程中同步代码执行完毕，会去任务队列中取任务执行，直到任务队列为空为止。</p> <p>但是，上面的任务队列只是笼统来讲的，实际上，任务队列又分两种情况，存储宏任务(macrotask)的宏任务队列以及存储微任务(microtask)的微任务队列。</p> <p>1、Macrotask任务：setTimeout，setInteveral，script标签，I/O，UI渲染</p> <p>2、Microtask任务：Promise，async/await，process.nextTick，Object.observe，MutationObserver</p> <p>当主线程代码执行完毕后，首先会取微任务队列任务执行，微任务队列执行完毕后，再去执行宏任务队列</p> <pre><code class=\\\"hljs js\\\">!<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>taskQuene</span>(<span class=hljs-params></span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'start task quene'</span>);\\n\\n  setTimeout(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'in immediate'</span>);\\n  }, <span class=hljs-number>0</span>)\\n\\n  <span class=hljs-keyword>var</span> s = <span class=hljs-keyword>new</span> <span class=hljs-built_in>Date</span>();\\n  <span class=hljs-keyword>while</span>(<span class=hljs-keyword>new</span> <span class=hljs-built_in>Date</span>() - s &lt; <span class=hljs-number>300</span>); <span class=hljs-comment>// 阻塞50ms</span>\\n\\n  <span class=hljs-built_in>Promise</span>.resolve({\\n    <span class=hljs-attr>then</span>: <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>resolve</span>) </span>{\\n      resolve(<span class=hljs-string>'in promise'</span>)\\n    }\\n  }).then(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>vale</span>) </span>{\\n    <span class=hljs-built_in>console</span>.log(vale)\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'promise then start'</span>);\\n    setTimeout(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{ <span class=hljs-comment>// 在执行微任务时，若内部存在宏任务，会将宏任务放入宏任务队列，由于此处在宏任务队列最后，所以会最后执行</span>\\n      <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'settimeout in promise then'</span>)\\n    }, <span class=hljs-number>0</span>)\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'promie then end'</span>);\\n  })\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'end task quene'</span>);\\n}()</code></pre> <p>最终打印顺序为：</p> <pre><code class=\\\"hljs js\\\">start task quene\\nend task quene\\n<span class=hljs-keyword>in</span> promise\\npromise then start\\npromie then end\\n<span class=hljs-keyword>in</span> immediate\\nsettimeout <span class=hljs-keyword>in</span> promise then</code></pre> <p>所谓event loops就是主线程代码执行完毕，执行微任务队列，微任务队列执行完毕，取宏任务队列代码执行，此时，宏任务进入主线程，作为又一次循环，依次进行同步代码执行，微任务调度，再取宏任务执行的过程。</p> <p><img src=\" + ___HTML_LOADER_REPLACER_0___ + \" alt=image></p> <p>再看一例:</p> <pre><code class=\\\"hljs js\\\"><span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>async1</span>(<span class=hljs-params></span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'async1 start'</span>);\\n  <span class=hljs-keyword>await</span> async2();\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'async1 end'</span>);\\n}\\n\\n<span class=hljs-keyword>async</span> <span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>async2</span>(<span class=hljs-params></span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'async2 start'</span>);\\n  <span class=hljs-keyword>return</span> <span class=hljs-keyword>new</span> <span class=hljs-built_in>Promise</span>(<span class=hljs-function>(<span class=hljs-params>resolve, reject</span>) =&gt;</span> {\\n    resolve();\\n    <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'async2 promise'</span>);\\n  })\\n}\\n\\n<span class=hljs-built_in>console</span>.log(<span class=hljs-string>'script start'</span>);\\nsetTimeout(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'setTimeout'</span>);\\n}, <span class=hljs-number>0</span>);  \\n\\nasync1();\\n\\n<span class=hljs-keyword>new</span> <span class=hljs-built_in>Promise</span>(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>resolve</span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'promise1'</span>);\\n  resolve();\\n}).then(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'promise2'</span>);\\n}).then(<span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params></span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(<span class=hljs-string>'promise3'</span>);\\n});\\n<span class=hljs-built_in>console</span>.log(<span class=hljs-string>'script end'</span>);</code></pre> <p>打印结果如下</p> <pre><code class=\\\"hljs js\\\">script start\\nasync1 start\\nasync2 start\\nasync2 promise\\npromise1\\nscript end\\npromise2\\npromise3\\nasync1 end\\nsetTimeout</code></pre> <p>参考链接：</p> <ul> <li><a href=https://www.jb51.net/article/115303.htm>详解JavaScript调用栈、尾递归和手动优化</a></li> <li><a href=http://www.ruanyifeng.com/blog/2015/04/tail-call.html>尾调用优化</a></li> <li><a href=https://tasaid.com/blog/20180118132704.html>任务队列与event loops</a></li> <li><a href=https://imweb.io/topic/5a27610da192c3b460fce29f>JavaScript任务队列的执行</a></li> <li><a href=https://segmentfault.com/a/1190000011198232>JavaScript 异步、栈、事件循环、任务队列</a></li> <li><a href=http://www.ruanyifeng.com/blog/2014/10/event-loop.html>阮一峰JavaScript 运行机制详解</a></li> </ul> </div>\";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/javascript/%E6%89%A7%E8%A1%8C%E6%A0%88%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E4%BB%A5%E5%8F%8A%E5%B0%BE%E8%B0%83%E7%94%A8.md?")},293:function(module,exports,__webpack_require__){"use strict";eval('\n\nmodule.exports = function (url, options) {\n  if (!options) {\n    // eslint-disable-next-line no-param-reassign\n    options = {};\n  } // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n\n\n  url = url && url.__esModule ? url.default : url;\n\n  if (typeof url !== \'string\') {\n    return url;\n  }\n\n  if (options.hash) {\n    // eslint-disable-next-line no-param-reassign\n    url += options.hash;\n  }\n\n  if (options.maybeNeedQuotes && /[\\t\\n\\f\\r "\'=<>`]/.test(url)) {\n    return "\\"".concat(url, "\\"");\n  }\n\n  return url;\n};\n\n//# sourceURL=webpack:///./node_modules/html-loader/dist/runtime/getUrl.js?')},294:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__["default"] = (__webpack_require__.p + "525aebdc34cc3b42fcf1152cfe530e5b.png");\n\n//# sourceURL=webpack:///./static/bg2014100802.png?')},295:function(module,exports){eval('// Module\nvar code = "<div class=note-title><p>执行上下文与变量提升</p> <p>正确理解执行上下文和执行栈的概念将使您成为更出色的 JavaScript 开发者</p> </div><div class=note-content><p><strong>一、函数执行上下文</strong></p> <p>​ 执行上下文又称执行环境，分全局执行环境与函数执行环境、eval三种，每个执行环境都包含三部分内容：</p> <ul> <li><p>变量对象/活动对象</p> <p>(1) 变量对象(VO)中存储了在上下文（环境）中定义的变量和函数声明，声明提升是就是发生在创建变量对象的过程中。</p> <p>(2) 活动对象：函数执行时产生 </p> </li> <li><p>作用域链</p> <blockquote> <p>闭包中的作用域链为静态作用域，指向所处函数上下文，因此闭包函数中访问外界变量时首先去所处函数环境中的变量对象中取对应的属性</p> </blockquote> </li> <li><p>this</p> </li> </ul> <p>参考链接：<a href=http://www.cnblogs.com/TomXu/archive/2012/01/12/2308594.html>javas核心</a>、<a href=http://www.cnblogs.com/TomXu/archive/2012/01/13/2308101.html>执行上下文</a>、<a href=http://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html>变量对象</a>、<a href=http://www.cnblogs.com/TomXu/archive/2012/01/17/2310479.html>this</a>、<a href=http://www.cnblogs.com/TomXu/archive/2012/01/18/2312463.html>作用域链</a>、<a href=https://www.jb51.net/article/104875.htm>尾调用</a></p> <p><strong>二、从执行上下文与变量对象角度去分析JS变量提示与函数提升</strong></p> <p>先看一个简单的例子</p> <pre><code class=\\"hljs js\\"><span class=hljs-built_in>console</span>.log(a);  <span class=hljs-comment>// 输出a方法</span>\\n<span class=hljs-built_in>console</span>.log(c);  <span class=hljs-comment>// 输出undefined</span>\\n<span class=hljs-keyword>var</span> c = a;\\n<span class=hljs-keyword>var</span> a = <span class=hljs-number>10</span>;\\n\\n<span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>a</span>(<span class=hljs-params>b</span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(b) <span class=hljs-comment>// 输出b的形参值</span>\\n  <span class=hljs-keyword>var</span> b = <span class=hljs-number>20</span>;\\n  <span class=hljs-built_in>console</span>.log(b) <span class=hljs-comment>// 输出20</span>\\n}\\n\\n<span class=hljs-built_in>console</span>.log(a);  <span class=hljs-comment>// 输出10</span>\\nc(<span class=hljs-number>5</span>)</code></pre> <p>分析：当代码执行时，首先形成全局执行上下文，而变量对象(VO)属于全局执行上下文的一部分，变量对象包括了：变量声明、函数声明(声明提升其实就是发生在变量对象定义过程中的)，在变量声明时若已存在相同名称的形参或函数，则变量声明不会干扰已存在的这类属性，也就是说变量对象中只存在相应的形参或函数声明，而同样名称变量声明不会再放入变量对象中，之后当代码执行到对应的变量赋值时，相当于为当前变量对象中已存在的函数声明或形参重新赋予新的值。</p> <p>填充VO的顺序是: 函数的形参 -&gt; 函数申明 -&gt; 变量申明。 </p> <pre><code class=\\"hljs js\\"><span class=hljs-comment>// 伪代码：全局环境变量对象</span>\\nGlobal(VO) = {\\n    <span class=hljs-attr>a</span>: <span class=xml><span class=hljs-tag>&lt;<span class=hljs-name>reference</span> <span class=hljs-attr>to</span> <span class=hljs-attr>FunctionDeclaration</span> \\"<span class=hljs-attr>d</span>\\"&gt;</span>,\\n    c: undefined,\\n}\\n// 伪代码：函数a执行环境中的活动对象(在函数执行上下文，VO不能直接访问，所以实际上由活动对象(AO)代替VO)\\n// VO是创建阶段生成的，AO则是执行阶段已VO为基准生成的。\\n// AO相比较VO而言，多了arguments、形参等属于函数特征的变量(此处暂无法确定，网上查询AO与VO解释不唯一)\\na(AO) = {\\n    arguments: {\\n        0: [b],\\n        length: 1,\\n        callee: a\\n    }\\n    b: undefined\\n}</span></code></pre> <p>最终，上述代码实际执行形式为：</p> <pre><code class=\\"hljs js\\"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>a</span>(<span class=hljs-params>b</span>) </span>{\\n  <span class=hljs-built_in>console</span>.log(b) <span class=hljs-comment>// 输出b的形参值</span>\\n  <span class=hljs-keyword>var</span> b = <span class=hljs-number>20</span>;\\n  <span class=hljs-built_in>console</span>.log(b) <span class=hljs-comment>// 输出20</span>\\n}\\n<span class=hljs-keyword>var</span> c = <span class=hljs-literal>undefined</span>;\\n\\n<span class=hljs-built_in>console</span>.log(a);  <span class=hljs-comment>// 输出a方法</span>\\n<span class=hljs-built_in>console</span>.log(c);  <span class=hljs-comment>// 输出undefined</span>\\n\\nc = a;\\na = <span class=hljs-number>10</span>;\\n\\n<span class=hljs-built_in>console</span>.log(a);  <span class=hljs-comment>// 输出10</span>\\nc(<span class=hljs-number>5</span>)</code></pre> <p>参考链接：<a href=http://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html>变量对象</a></p> </div>";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/javascript/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87.md?')},296:function(module,exports){eval("// Module\nvar code = \"<div class=note-title><p>惰性函数</p> <p>惰性函数即函数执行后，原函数在函数内部被重新定义，之后调用只执行重新定义的函数，常用在内部状态稳定不变，即执行环境条件确定后，之后无论调用多少次函数，都返回同样结果或函数，此时可以使用惰性函数，直接重新定义函数。</p> </div><div class=note-content><pre><code class=\\\"hljs js\\\"><span class=hljs-function><span class=hljs-keyword>function</span> <span class=hljs-title>addEvent</span>(<span class=hljs-params>type, element, fun</span>) </span>{\\n  <span class=hljs-keyword>if</span> (element.addEventListener) {\\n    addEvent = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>type, element, fun</span>) </span>{\\n      element.addEventListener(type, fun, <span class=hljs-literal>false</span>);\\n    }\\n  } <span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (element.attachEvent) {\\n    addEvent = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>type, element, fun</span>) </span>{\\n      element.attachEvent(<span class=hljs-string>'on'</span> + type, fun);\\n    }\\n  } <span class=hljs-keyword>else</span> {\\n    addEvent = <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>type, element, fun</span>) </span>{\\n      element[<span class=hljs-string>'on'</span> + type] = fun;\\n    }\\n  }\\n  <span class=hljs-keyword>return</span> addEvent(type, element, fun);\\n}</code></pre> </div>\";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/javascript/%E6%83%B0%E6%80%A7%E5%87%BD%E6%95%B0.md?")},297:function(module,exports){eval('// Module\nvar code = "<div class=note-title><p>http协议</p> <p>http协议是基于TCP/IP协议之上的应用层协议，HTTP默认端口：80，HTTPS默认端口443</p> </div><div class=note-content></div>";\n// Exports\nmodule.exports = code;\n\n//# sourceURL=webpack:///./sources/http/%E8%AF%BB%E6%87%82http%E5%8D%8F%E8%AE%AE.md?')},298:function(module,exports){eval("\n\n//# sourceURL=webpack:///./app/loadImages.ts?")}}]);